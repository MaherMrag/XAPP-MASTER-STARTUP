//Fold All : Ctrl + K + 0
//Unfold All : Ctrl + K + J
//mongodb://localhost:27017/xapp

var XAPP = (function () {
    var initialised = false;

    function init(options) {
        if (initialised) {
            throw new Error("XAPP already initialised");
        }
        initialised = true;
        initialised = true;
        ace.require("ace/ext/language_tools");
        options = options || {};
        options.apiRootUrl = options.apiRootUrl || "";
        if (options.apiRootUrl && !/\/$/.test(options.apiRootUrl)) {
            options.apiRootUrl = options.apiRootUrl + "/";
        }
        options.target = $("#red-ui-editor");
        console.log("XAPP navbar init");
        XAPP.navbar.init(options);
        console.log("XAPP toolbar init");
        XAPP.toolbar.init(options);
        console.log("XAPP status init");
        XAPP.status.init(options);
        console.log("XAPP dialog init");
        XAPP.dialog.init();
        console.log("XAPP treelist init");
        XAPP.treelist.init();
        console.log("XAPP menu init");
        XAPP.menu.init();

    }



    var loader = {
        init: function () {
            var wrapper = $('<div id="red-ui-loading-progress"></div>').hide();
            var container = $('<div>').appendTo(wrapper);
            var label = $('<div>', { class: "red-ui-loading-bar-label" }).appendTo(container);
            var bar = $('<div>', { class: "red-ui-loading-bar" }).appendTo(container);
            var fill = $('<span>').appendTo(bar);
            return wrapper;
        },
        start: function (text, prcnt) {
            if (text) {
                loader.reportProgress(text, prcnt)
            }
            $("#red-ui-loading-progress").show();
        },
        reportProgress: function (text, prcnt) {
            $(".red-ui-loading-bar-label").text(text);
            $(".red-ui-loading-bar span").width(prcnt + "%")
        },
        end: function () {
            $("#red-ui-loading-progress").hide();
            loader.reportProgress("", 0);
        }
    }

    return {
        init: init,
        loader: loader,
    }

})();

XAPP.events = (function () {
    var handlers = {};

    function on(evt, func) {
        handlers[evt] = handlers[evt] || [];
        handlers[evt].push(func);
    }
    function off(evt, func) {
        var handler = handlers[evt];
        if (handler) {
            for (var i = 0; i < handler.length; i++) {
                if (handler[i] === func) {
                    handler.splice(i, 1);
                    return;
                }
            }
        }
    }
    function emit() {
        var evt = arguments[0]
        var args = Array.prototype.slice.call(arguments, 1);
        if (RED.events.DEBUG) {
            console.warn(evt, args);
        }
        if (handlers[evt]) {
            for (var i = 0; i < handlers[evt].length; i++) {
                try {
                    handlers[evt][i].apply(null, args);
                } catch (err) {
                    console.warn("RED.events.emit error: [" + evt + "] " + (err.toString()));
                    console.warn(err);
                }
            }

        }
    }
    return {
        on: on,
        off: off,
        emit: emit
    }
})();

XAPP.actions = (function () {
    var actions = {

    }

    function addAction(name, handler) {
        actions[name] = handler;
    }
    function removeAction(name) {
        delete actions[name];
    }
    function getAction(name) {
        return actions[name];
    }
    function invokeAction(name, args) {
        if (actions.hasOwnProperty(name)) {
            actions[name](args);
        }
    }
    function listActions() {
        var result = [];
        Object.keys(actions).forEach(function (action) {
            var shortcut = RED.keyboard.getShortcut(action);
            var isUser = false;
            if (shortcut) {
                isUser = shortcut.user;
            } else {
                isUser = !!RED.keyboard.getUserShortcut(action);
            }
            result.push({
                id: action,
                scope: shortcut ? shortcut.scope : undefined,
                key: shortcut ? shortcut.key : undefined,
                user: isUser
            })
        })
        return result;
    }
    return {
        add: addAction,
        remove: removeAction,
        get: getAction,
        invoke: invokeAction,
        list: listActions
    }
})();


XAPP.utils = (function () {
    function getDataTypeAsString(S7Object, choose) {
        let ret = '';
        // cases grabbed from HTML file. Object operators2 within oneditprepare in the configuration part!!
        switch (S7Object.S7_Datatype) {
            case 'X':
                ret = ((choose && choose === 'DB') ? ('X') : ('X'));
                break;
            case 'B':
            case 'uint8':
                ret = ((choose && choose === 'DB') ? ('BYTE') : ('B'));
                break;
            case 'W':
            case 'uint16':
                ret = ((choose && choose === 'DB') ? ('WORD') : ('W'));
                break;
            case 'D':
            case 'uint32':
                ret = ((choose && choose === 'DB') ? ('DWORD') : ('D'));
                break;
            case 'I':
            case 'int16':
                ret = ((choose && choose === 'DB') ? ('INT') : ('I'));
                break;
            case 'DI':
            case 'int32':
                ret = ((choose && choose === 'DB') ? ('DINT') : ('DI'));
                break;
            case 'CHAR':
                ret = ((choose && choose === 'DB') ? ('CHAR') : ('C'));
                break;
            case 'STRING':
                ret = ((choose && choose === 'DB') ? ('STRING') : ('S'));
                break;
            case 'R':
                ret = ((choose && choose === 'DB') ? ('REAL') : ('R'));
                break;
            case 'TIMER':
                ret = ((choose && choose === 'DB') ? ('TIMER') : ('TIMER'));// placeholder!
                break;
            case 'COUNTER':
                ret = ((choose && choose === 'DB') ? ('COUNTER') : ('COUNTER'));// placeholder!
                break;
            default:
                ret = undefined;
        }
        return ret;
    }
    function wrapData(S7Object, choose) {

        let ret = S7Object;
        switch (S7Object.S7_Type) {
            case 'I':
            case 'Q': // X,BYTE,WORD,DWORD,INT,DINT,CHAR,STRING,R,TIMER,COUNTER
            case 'M':
            case 'PI':
            case 'PQ':
                if (S7Object.S7_Datatype === 'X') {
                    // Bool
                    ret = S7Object.S7_Type + S7Object.S7_Offset + '.' + S7Object.S7_BitOffset;// I0.0
                } else if (S7Object.S7_Datatype === 'CHAR') {
                    // CHAR
                    ret = S7Object.S7_Type + getDataTypeAsString(S7Object) + S7Object.S7_Offset;// MC0
                } else {
                    // BYTE,WORD,DWORD,INT,DINT,STRING,R,TIMER,COUNTER
                    if (S7Object.S7_Quantity > 1) {
                        if (choose === 'path') {
                            // IB0-IBx into IB0..x
                            ret = S7Object.S7_Type + getDataTypeAsString(S7Object) + S7Object.S7_Offset + '..' + (S7Object.S7_Quantity - 1);
                        } else if (choose === 'data') {
                            // IB0-IBx into IB0.x
                            ret = S7Object.S7_Type + getDataTypeAsString(S7Object) + S7Object.S7_Offset + '.' + S7Object.S7_Quantity;
                        } else {
                            ret = null;
                        }
                    } else {
                        console.log("else")
                        ret = S7Object.S7_Type + getDataTypeAsString(S7Object) + S7Object.S7_Offset;	// IB0
                    }
                }
                break;
            case 'DB':
                if (S7Object.S7_Datatype === 'X') {
                    // Bool
                    ret = S7Object.S7_Type + S7Object.S7_DBnum + '.' + getDataTypeAsString(S7Object, 'DB') + S7Object.S7_Offset + '.' + S7Object.S7_BitOffset;	// DB10.DBX0.1  into  DB10,X0.1
                } else if (S7Object.S7_Datatype === 'CHAR') {
                    // CHAR
                    ret = S7Object.S7_Type + S7Object.S7_DBnum + '.' + getDataTypeAsString(S7Object, 'DB') + S7Object.S7_Offset;// DB10.DBC0 into 'DB10,CHAR0'
                } else {
                    // BYTE,WORD,DWORD,INT,DINT,STRING,R,TIMER,COUNTER
                    if (S7Object.S7_Quantity > 1) {
                        // Quantity >1 (array)
                        if (choose === 'path') {
                            ret = S7Object.S7_Type + S7Object.S7_DBnum + '.' + getDataTypeAsString(S7Object, 'DB') + S7Object.S7_Offset + '..' + (S7Object.S7_Quantity - 1);// DB10.DBW0-DB10.DBW2   into 'DB10,WORD1..2'
                        } else if (choose === 'data') {
                            ret = S7Object.S7_Type + S7Object.S7_DBnum + '.' + getDataTypeAsString(S7Object, 'DB') + S7Object.S7_Offset + '.' + S7Object.S7_Quantity;// DB10.DBW0-DB10.DBW2   into 'DB10,WORD1.2'
                        } else {
                            ret = null;// default
                        }
                    } else {
                        ret = S7Object.S7_Type + S7Object.S7_DBnum + '.' + getDataTypeAsString(S7Object, 'DB') + S7Object.S7_Offset;// DB10.DBW0 into 'DB10,WORD1'
                    }
                }
                break;
            case 'T':
                ret = S7Object.S7_Type + S7Object.S7_Offset;
                break;
            case 'C':
                ret = S7Object.S7_Type + S7Object.S7_Offset;
                break;
            default:
                ret = null;
        }
        return ret;
    }
    return {
        wrapData: wrapData,
    }
})();

XAPP.nodes = (function () {

})

XAPP.treelist = (function () {
    var Tree = {};
    var curSrcNode, curType;
    var actions = {

        saveSettings: () => {
            var TreeNodes = RED.trees.tree.getZTreeObj("tree").getNodes();
            RED.settings.set('treeNodes', TreeNodes);
        },

        getWorkspaceId: () => {
            return RED.nodes.defaultWorkspace()
        },
        getParentId: (node, type) => {

            while (node.type !== type) {
                node = Tree.getNodeByTId(node.parentTId)
            }
            return node.id
        },
        getRoot: (node) => {
            while (node.level !== 1) {
                node = Tree.getNodeByTId(node.parentTId)
            }
            return node
        },
        getConnectionId: () => {
            var nn = Tree.getSelectedNode()
            while (nn.type !== 's7.config') {
                nn = Tree.getNodeByTId(nn.parentTId)
            }
            return nn.id
        },
        getDataBaseId: () => {
            var nn = Tree.getSelectedNode()
            while (nn.type !== 's7.db') {
                nn = Tree.getNodeByTId(nn.parentTId)
            }
            return nn.id
        },
        getSelectedNodeId: () => {
            var nn = Tree.getSelectedNode()
            if (nn) {
                return nn.id;
            }
            return;
        },

        //Add Node
        addstatemachine: () => {
            var nn = {};
            nn.id = RED.nodes.id();
            nn.type = "s7.statemachine";
            nn.name = "state_" + nn.id.substring(1, 5);
            nn.class = "icon-statemachine";
            nn.parentid = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.payload = {}
            nn.states = {}
            nn.datapoints = {}
            nn.x = 0
            nn.y = 0
            nn.width = 5;
            nn.height = 5;
            actions.addNode(nn)
        },
        addNode: function (nn) {
            XAPP.menu.hide();
            nn._def = RED.nodes.getType(nn.type);
            console.log('nn._def :', nn._def)
            for (var d in nn._def.defaults) {
                if (nn._def.defaults.hasOwnProperty(d)) {
                    if (nn._def.defaults[d].value !== undefined) {
                        nn[d] = JSON.parse(JSON.stringify(nn._def.defaults[d].value));
                    }
                }
            }
            if (nn._def.onadd) {
                try {
                    nn._def.onadd.call(nn);
                } catch (err) {
                    console.log("Definition error: " + nn.type + ".onadd:", err);
                }
            }

            console.log('nn added :', nn)

            Tree.addNodes(Tree.getSelectedNodes()[0], nn);
            RED.nodes.add(nn);
            RED.nodes.dirty(true);



            if (nn._def.autoedit) {
                RED.editor.edit(nn);
            }



        },
        addBatch: () => {
            var nn = {};
            nn.id = RED.nodes.id();
            nn.type = "s7.batch";
            nn.name = "batch_" + nn.id.substring(1, 5);
            nn.class = "icon-ui-datapoint";
            nn.parentid = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            actions.addNode(nn)
        },

        addAlarm: () => {
            var nn = {};
            nn.id = RED.nodes.id();
            nn.name = "al_" + nn.id.substring(1, 5);
            nn.type = "s7.alarm";
            nn.parentid = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.class = "icon-alarm";
            nn.payload = {}
            nn.x = 0
            nn.y = 0
            actions.addNode(nn);
        },
        addStatus: () => {
            var nn = {};
            nn.id = RED.nodes.id();
            nn.name = "st_" + nn.id.substring(1, 5);
            nn.type = "s7.status";
            nn.parentid = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.class = "icon-alarm";
            nn.payload = {}
            nn.x = 0
            nn.y = 0
            actions.addNode(nn);
        },
        addPhase: () => {
            var nn = {};
            nn.id = RED.nodes.id();
            nn.name = "ph_" + nn.id.substring(1, 5);
            nn.type = "s7.phase";
            nn.parentid = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.class = "icon-alarm";
            nn.payload = {}
            nn.x = 0
            nn.y = 0
            actions.addNode(nn);
        },
        addTrend: () => {
            var nn = {};
            nn.id = RED.nodes.id();
            nn.name = "ph_" + nn.id.substring(1, 5);
            nn.type = "s7.trend";
            nn.parentid = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.class = "icon-alarm";
            nn.datapoints = {}
            nn.x = 0
            nn.y = 0
            actions.addNode(nn);
        },

        addConnection: () => {
            var nn = {};
            nn.id = RED.nodes.id();
            nn.type = "s7.config";
            nn.name = "con_" + nn.id.substring(1, 5);
            nn.class = "icon-connection";
            nn.payload = {}
            nn.users = []
            actions.addNode(nn)
        },
        addTag: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "s7.io"
            nn.group = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.connection = actions.getConnectionId()
            nn.name = "tag_" + nn.id.substring(1, 5)
            nn.topic = ''
            nn.class = "icon-tag"
            nn.x = 0
            nn.y = 0

            actions.addNode(nn)
        },

        addGroup: () => {
            var nn = {};
            nn.id = RED.nodes.id();
            nn.name = "gr_" + nn.id.substring(1, 5);
            nn.z = actions.getWorkspaceId()
            nn.type = "s7.group";
            nn.class = "icon-group";
            nn.users = []
            nn.connection = actions.getConnectionId()
            actions.addNode(nn);
        },

        addrpreport: () => {
            var nn = {};
            nn.id = RED.nodes.id();
            nn.type = "rp.report";
            nn.name = "rp_" + nn.id.substring(1, 5)
            nn.tab = actions.getSelectedNodeId();
            nn.class = "icon-ui-group";
            nn.users = []
            actions.addNode(nn)
        },

        addrpwidget: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "rp.widget"
            nn.parentid = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.name = "wd_" + nn.id.substring(1, 5)
            nn.class = "icon-ui-chart"
            nn.width = 1;
            nn.height = 1;
            nn.x = 0;
            nn.y = 0;
            actions.addNode(nn)
        },

        addrptemplate: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "rp.template"
            nn.parentid = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.name = "wd_" + nn.id.substring(1, 5)
            nn.class = "icon-ui-chart"
            nn.width = 1;
            nn.height = 1;
            nn.x = 0;
            nn.y = 0;
            actions.addNode(nn)
        },
        addrpchart: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "rp.chart"
            nn.parentid = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.name = "wd_" + nn.id.substring(1, 5)
            nn.class = "icon-ui-chart"
            nn.width = 1;
            nn.height = 1;
            nn.x = 0;
            nn.y = 0;
            actions.addNode(nn)
        },



        adduigroup: () => {
            var nn = {};
            nn.id = RED.nodes.id();
            nn.type = "ui.group";
            nn.name = "gr_" + nn.id.substring(1, 5)
            nn.tab = actions.getSelectedNodeId();
            nn.class = "icon-ui-group";
            nn.users = []
            actions.addNode(nn)
        },
        adduitab: () => {
            var nn = {};
            nn.id = RED.nodes.id();
            nn.type = "ui.tab";
            nn.order = 1;
            nn.name = "tab_" + nn.id.substring(1, 5)
            nn.class = "icon-ui-tab";
            nn.users = []
            actions.addNode(nn)
        },


        adduipiechart: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "ui.piechart"
            nn.parentid = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.name = "pie_" + nn.id.substring(1, 5)

            nn.datapoints = {}
            actions.addNode(nn)


        },
        //adduilinechart

        adduispark: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "ui.spark";
            nn.parentid = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId();
            actions.addNode(nn)



        },


        adduiprogressbox: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "ui.progressBox"
            nn.parentid = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.name = "ProgBox_" + nn.id.substring(1, 5)
            nn.class = "icon-ui-progressbox"
            nn.datapoints = {}
            nn.x = '0';
            nn.y = '0';
            nn.width = '5';
            nn.height = '5';
            actions.addNode(nn)


        },

        adduiprogressbar: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "ui.progressBar"
            nn.parentid = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.name = "ProgBar_" + nn.id.substring(1, 5)
            nn.class = "icon-ui-progressbar"
            nn.datapoints = {}
            nn.x = '0';
            nn.y = '0';
            nn.width = '5';
            nn.height = '5';
            actions.addNode(nn)


        },

        adduiinfobox: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "ui.infoBox"
            nn.parentid = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.name = "info_" + nn.id.substring(1, 5)
            nn.class = "icon-ui-infobox"
            nn.datapoints = {}
            nn.x = '0';
            nn.y = '0';
            nn.width = '5';
            nn.height = '5';
            actions.addNode(nn)
        },

        adduiinline: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "ui.inline"
            nn.parentid = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.name = "inline_" + nn.id.substring(1, 5)
            nn.class = "icon-ui-inline"
            nn.datapoints = {}
            nn.x = '0';
            nn.y = '0';
            nn.width = '5';
            nn.height = '5';
            actions.addNode(nn)

        },


        adduigauge: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "ui.gauge"
            nn.parentid = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.name = "gauge_" + nn.id.substring(1, 5)
            actions.addNode(nn)
        },

        adduibarchart: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "ui.barchart"
            nn.parentid = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.datapoints = {}
            actions.addNode(nn)
        },

        adduitemplate: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "ui.template"
            nn.parentid = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.name = "bar_" + nn.id.substring(1, 5)
            nn.class = "icon-file"
            actions.addNode(nn)
        },

        adddatabase: () => {
            var nn = {}

            nn.id = RED.nodes.id();
            nn.type = "s7.db";
            nn.name = "db_" + nn.id.substring(1, 5);
            nn.class = "icon-database";
            nn.payload = {}
            nn.users = []
            actions.addNode(nn)

        },

        addcollection: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "s7.db.in"
            nn.z = actions.getWorkspaceId()
            nn.configNode = actions.getDataBaseId();
            nn.name = "coll_" + nn.id.substring(1, 5);
            nn.class = "icon-collection"
            nn.x = 0
            nn.y = 0
            actions.addNode(nn)
        },

        addmobile: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "m.mmobile"
            nn.group = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.name = "mob_" + nn.id.substring(1, 5)
            nn.class = "icon-mobile"
            nn.payload = {}
            nn.x = 0
            nn.y = 0
            actions.addNode(nn)
        },
        addmwidget: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "m.widget"
            nn.group = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.name = "wid_" + nn.id.substring(1, 5)
            nn.class = "icon-mwidget"
            nn.payload = {}
            nn.x = 0
            nn.y = 0
            actions.addNode(nn)
        },


        addmpiechart: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "m.piechart"
            nn.group = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.name = "pie_" + nn.id.substring(1, 5)
            nn.class = "icon-ui-piechart"
            nn.payload = {}
            nn.x = 0
            nn.y = 0
            actions.addNode(nn)
        },
        addmbarchart: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "m.barchart"
            nn.group = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.name = "bar_" + nn.id.substring(1, 5)
            nn.class = "icon-ui-barchart"
            nn.payload = {}
            nn.x = 0
            nn.y = 0
            actions.addNode(nn)
        },
        adddatapoint: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.type = "ui.datapoint"
            nn.parent = actions.getSelectedNodeId();
            nn.group = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.name = "data_" + nn.id.substring(1, 5)
            nn.payload = {}
            nn.class = "icon-ui-datapoint"
            nn.x = 0
            nn.y = 0
            console.log('Tag :', nn);
            actions.addNode(nn)
        },
        addcalculator: () => {
            var nn = {}
            nn.id = RED.nodes.id();
            nn.parent = actions.getSelectedNodeId();
            nn.type = "s7.calculator"
            nn.group = actions.getSelectedNodeId();
            nn.parentId = actions.getSelectedNodeId();
            nn.z = actions.getWorkspaceId()
            nn.payload = {}
            nn.name = "calc_" + nn.id.substring(1, 5)
            nn.class = "icon-calculator"
            nn.x = 0
            nn.y = 0

            actions.addNode(nn)
        },
        importNodes: () => {
            XAPP.menu.hide();
            XAPP.dialog.import(Tree);
        },

        exportNodes: () => {
            XAPP.menu.hide();
            XAPP.dialog.export(Tree);
        },

        addTagLogging: () => false,
        linknodes: () => {
            var src = RED.nodes.node(Tree.getSelectedNodes()[0].id)
            var dst = RED.nodes.node(Tree.getSelectedNodes()[0].children[0].id)

            var src_port = 0
            var addedLinks = [];
            var existingLink = RED.nodes.filterLinks({ source: src, target: dst, sourcePort: src_port }).length !== 0;
            if (!existingLink) {
                console.log("source :", src.id)
                console.log("target :", dst.id)
                var link = { source: src, sourcePort: src_port, target: dst };
                RED.nodes.addLink(link);
                addedLinks.push(link);
                //updateActiveNodes();
                RED.nodes.dirty(true);
            }
        },
        replace: () => false,
        cut: () => { //Maher
            XAPP.menu.hide();
            var nodes = Tree.getSelectedNodes();



            var parentNode = RED.nodes.node(nodes[0].pId); //MMM
            var curNodeID = nodes[0].id;

            if (parentNode.datapoints) {
                delete parentNode.datapoints[curNodeID]
            }


            if (nodes && nodes.length > 0) {
                var editing_node = nodes[0];
                Tree.removeNode(editing_node);
            }




            RED.nodes.dirty(true);

        },
        fontCss: (treeNode) => {
            var aObj = $("#" + treeNode.tId + "_a");
            aObj.removeClass("copy").removeClass("cut");
            if (treeNode === curSrcNode) {
                if (curType == "copy") {
                    aObj.addClass(curType);
                } else {
                    aObj.addClass(curType);
                }
            }
        },
        setCurSrcNode: (treeNode) => {
            if (curSrcNode) {
                delete curSrcNode.isCur;
                var tmpNode = curSrcNode;
                curSrcNode = null;
                actions.fontCss(tmpNode);
            }
            curSrcNode = treeNode;
            if (!treeNode) return;

            curSrcNode.isCur = true;
            Tree.cancelSelectedNode();
            actions.fontCss(curSrcNode);
        },
        copy: (e) => {
            XAPP.menu.hide();
            var nodes = Tree.getSelectedNodes();
            if (nodes.length == 0) {
                var message = "Please select one node at first...";

                var activeNotifyMessage = RED.notify(message, {
                    modal: true,
                    fixed: true,
                    buttons: [
                        {
                            text: 'Cancel',
                            click: function () {
                                activeNotifyMessage.close();
                                activeNotifyMessage = null;
                            }
                        },
                    ]
                });


                return;
            }






            curType = "copy";
            actions.setCurSrcNode(nodes[0]);
        },
        paste: (e) => {
            XAPP.menu.hide();
            if (!curSrcNode) {

                var message = "Please select one node to copy or cut at first...";

                var activeNotifyMessage = RED.notify(message, {
                    modal: true,
                    fixed: true,
                    buttons: [
                        {
                            text: 'Cancel',
                            click: function () {
                                activeNotifyMessage.close();
                                activeNotifyMessage = null;
                            }
                        },
                    ]
                });


                return;
            }

            var nodes = Tree.getSelectedNodes();
            var targetNode = nodes.length > 0 ? nodes[0] : null;




            var dstNode = RED.nodes.node(nodes[0].id);
            if (dstNode) {
                if (dstNode.datapoints[curSrcNode.id]) {
                    var message = "Copy failed, the target node already contains this node....";

                    var activeNotifyMessage = RED.notify(message, {
                        modal: true,
                        fixed: true,
                        buttons: [
                            {
                                text: 'Cancel',
                                click: function () {
                                    activeNotifyMessage.close();
                                    activeNotifyMessage = null;
                                }
                            },
                        ]
                    });

                } else {
                    targetNode = Tree.copyNode(targetNode, curSrcNode, "inner");
                    targetNode.isCopy = true;
                    actions.setCurSrcNode();
                    delete targetNode.isCur;
                    Tree.selectNode(targetNode);
                    var srcNode = RED.nodes.node(targetNode.id);
                    dstNode.datapoints[srcNode.id] = { id: srcNode.id, name: srcNode.name, color: srcNode.color };

                    RED.nodes.dirty(true)

                }
            }



        },
        refresh: () => {
            //MaherRefresh
            XAPP.menu.hide();
            var selected_node = Tree.getSelectedNodes();
            var id = selected_node[0].id;
            var node = RED.nodes.node(id)

            if (node) {
                if (node._def.onwsprepare) {
                    try {
                        node._def.onwsprepare.call(node);
                    } catch (err) {
                        console.log("onwsprepare", node.id, node.type, err.toString());
                    }
                }
            }
        },

        remove: function () {
            XAPP.menu.hide();
            var selected_node = Tree.getSelectedNodes();
            var children = selected_node[0].children
            var message = ""
            if (selected_node && selected_node.length > 0) {
                if (children && children.length > 0) {
                    message = $('<p>').text('If you delete this node will be deleted along with sub-nodes. \n\nPlease confirm!');
                } else {
                    message = $('<p>').text('Are you sure to remove this node? \n\n Please confirm!');
                }

                var activeNotifyMessage = RED.notify(message, {
                    modal: true,
                    fixed: true,
                    buttons: [
                        {
                            text: RED._('deploy.confirm.button.ignore'),
                            click: function () {
                                activeNotifyMessage.close();
                                activeNotifyMessage = null;
                            }
                        },
                        {
                            text: 'Confirme',
                            class: "primary",
                            click: function () {


                                actions.removeNodes(selected_node)
                                Tree.removeNode(selected_node[0]);


                                var n = selected_node[0].getParentNode();
                                n.isParent = true;
                                Tree.updateNode(n)

                                RED.nodes.dirty(true);
                                activeNotifyMessage.close();
                                activeNotifyMessage = null;

                            }
                        }
                    ]
                });
            }
        },
        removeNodes: function (nodes) {
            var children;
            for (var c = 0; c < nodes.length; c++) {
                if (RED.nodes.node(nodes[c].id)) {
                    if (nodes[c].isCopy) { } else {
                        RED.nodes.remove(nodes[c].id)
                    }
                    children = nodes[c].children;
                    if (children && children.length > 0) {
                        actions.removeNodes(children)
                    }
                }
            }
        }

    }
    var events = {
        editorsave: (node) => {
            var nn = Tree.getNodesByParam('id', node.id)[0]//Tree.getSelectedNodes()[0];
            nn.name = node.name
            Tree.updateNode(nn)
            Tree.selectNode(nn)
        }
    }
    function init() {
        var callback = {
            general: {
                beforeDrag: (treeId, treeNodes) => (treeNodes[0].level > 1), //!treeNodes[0].isParent
                onAsyncError: () => null,
                onAsyncSuccess: () => null,
                onNodeCreated: () => null,
                onClick: (event, treeId, treeNode, clickFlag) => {




                    if (treeNode) {
                        console.log("Node orig :", RED.nodes.node(treeNode.id))
                        console.log("Node Tree :", treeNode)
                        console.log('is copy :', treeNode.isCopy);


                        // treeNodes.view.onwsprepare(node)
                        /*                    var definition = node._def
                                           if (definition.onwsprepare)
                                           {
                                               definition.onwsprepare.call(node)
                                               console.log("Nodeee :",node)
                                           }
                                            */

                        //Node Clicked
                        console.log("treeNode.type  :", treeNode.type)


                        if (treeNode.type == 's7.config') {
                            /* RED.container.draw_s7_config(id) */
                        }

                        if (treeNode.name == 'Demo 01') {
                            RED.demo.demo_echarts(treeNode.id)
                        }

                        if (treeNode.name == 'Demo 02') {
                            RED.demo.demo_tables()
                            /* RED.demo.demo_gridstack(); */
                        }

                        if (treeNode.name == 'Demo 03') {
                            //RED.demo.demo_gauges()

                            RED.demo.demo_synop()
                        }

                        if (treeNode.name == 'Demo 04') {
                            RED.demo.demo_dashboards()
                        }
                        if (treeNode.name == 'Demo 05') {
                            RED.demo.demo_widget()
                        }
                        if (treeNode.name == 'Demo 06') {
                            RED.demo.demo_templates()
                        }

                        if (treeNode.name == 'Demo 07') {
                            RED.demo.demo_gridstack()
                        }

                        if (treeNode.name == 'Demo 08') {
                            RED.demo.demo_datatable()
                        }

                        if (treeNode.name == 'Demo 09') {
                            RED.demo.demo_ztree()
                        }

                        if (treeNode.name == 'Demo 10') {
                            RED.demo.demo_io()
                        }









                    }
                },
                onDblClick: (event, treeId, treeNode, clickFlag) => {
                    if (treeNode) {
                        var node = RED.nodes.node(treeNode.id);
                        RED.editor.edit(node);
                    }


                },

                onRightClick: (event, treeId, treeNode) => {

                    XAPP.menu.load(treeNode)

                    if (!treeNode && event.target.tagName.toLowerCase() != "button" && $(event.target).parents("a").length == 0) {
                        Tree.cancelSelectedNode();
                        XAPP.menu.show("root", event.clientX, event.clientY);
                    } else if (treeNode && !treeNode.noR) {
                        Tree.selectNode(treeNode);
                        XAPP.menu.show("node", event.clientX, event.clientY);
                    }
                },
                onMouseDown: () => null,
                onMouseUp: () => null,
                onExpand: () => null,
                onCollapse: () => null,
                onRemove: () => null,
                onDrag: () => null,
                onDragMove: () => null,
                onDrop: (event, treeId, treeNodes, targetNode, moveType, isCopy) => {

                    //Pie Chart
                    treeNodes[0].isCopy = true;
                    if (targetNode) {
                        var dstNode = RED.nodes.node(targetNode.id);
                        if (dstNode.datapoints) {
                            var sourceId = treeNodes[0].id
                            var srcNode = RED.nodes.node(sourceId);
                            dstNode.datapoints[srcNode.id] = { id: srcNode.id, name: srcNode.name, color: srcNode.color };

                            RED.nodes.dirty(true)
                        }
                    }



                    /*                 if (targetNode) {
                    
                                        var id =actions.getParentId(treeNodes[0], 's7.group')
                                        var sourceId = treeNodes[0].id
                    
                                        var sourceNode = RED.nodes.node(sourceId)
                                        sourceNode.group = id
                                        RED.nodes.dirty(true)
                    
                                    } */
                },
            },
            view: {
                addHoverDom: (treeId, treeNode) => {
                },
                removeHoverDom: (treeId, treeNode) => {
                    $("#addBtn_" + treeNode.tId).unbind().remove();
                },
            },
            drag: {
                getPermission: (action, sourceType, targetType) => {
                    //Permissions
                    var permission = {
                        'inner': {
                            's7.io': ['s7.group', 'ui.piechart', 'ui.linechart', 'ui.barchart', 's7.calculator', 'ui.infoBox', 'ui.progressBox', 'ui.spark', 'ui.inline', 'ui.progressBar', 'm.widget', 'm.piechart', 'm.barchart', 's7.trend'],
                            's7.alarm': ['s7.group'],
                            /* 'ui.piechart':['s7.mobile'] */
                        },
                        'prev': {
                            's7.io': ['s7.io', 's7.alarm'],
                            's7.alarm': ['s7.alarm', 's7.io'],
                            'ui.barchart': ['ui.barchart', 'ui.template', 'ui.gauge', 'ui.piechart', 'ui.spark'],
                            'ui.template': ['ui.barchart', 'ui.template', 'ui.gauge', 'ui.piechart', 'ui.spark'],
                            'ui.gauge': ['ui.barchart', 'ui.template', 'ui.gauge', 'ui.piechart', 'ui.spark'],
                            'ui.piechart': ['ui.barchart', 'ui.template', 'ui.gauge', 'ui.piechart', 'ui.spark'],
                            'ui.spark': ['ui.barchart', 'ui.template', 'ui.gauge', 'ui.piechart', 'ui.spark'],

                        },
                        'next': {
                            's7.io': ['s7.io', 's7.alarm'],
                            's7.alarm': ['s7.alarm', 's7.io'],
                            'ui.barchart': ['ui.barchart', 'ui.template', 'ui.gauge', 'ui.piechart', 'ui.spark'],
                            'ui.template': ['ui.barchart', 'ui.template', 'ui.gauge', 'ui.piechart', 'ui.spark'],
                            'ui.gauge': ['ui.barchart', 'ui.template', 'ui.gauge', 'ui.piechart', 'ui.spark'],
                            'ui.piechart': ['ui.barchart', 'ui.template', 'ui.gauge', 'ui.piechart', 'ui.spark'],
                            'ui.spark': ['ui.barchart', 'ui.template', 'ui.gauge', 'ui.piechart', 'ui.spark'],
                        },
                        'copy': {
                            's7.io': ['s7.io', 'ui.piechart', 'ui.barchart', 'ui.linechart', 's7.mobile', 's7.calculator', 'ui.infoBox', 'ui.progressBox', 'ui.spark', 'ui.inline', 'ui.progressBar', 'm.widget', 'm.piechart', 'm.barchart', 's7.trend'],
                            's7.alarm': ['s7.alarm', 's7.io'],
                            /* 'ui.piechart':['s7.mobile'] */
                        },
                        'move': {
                            's7.io': ['s7.io', 's7.alarm'],
                            's7.alarm': ['s7.alarm', 's7.io'],
                        }
                    }

                    var category = permission[action]
                    var permissionsArray = category[sourceType]
                    if (permissionsArray && permissionsArray.length > 0) {
                        for (var i = 0; i < permissionsArray.length; i++) {
                            if (permissionsArray[i] === targetType) return true
                        }
                    }

                    return false

                },

                prevTree: (treeId, treeNodes, targetNode) => {
                    console.log('Prev :', callback.drag.getPermission('prev', treeNodes[0].type, targetNode.type))
                    return callback.drag.getPermission('prev', treeNodes[0].type, targetNode.type)
                },

                nextTree: (treeId, treeNodes, targetNode) => {
                    console.log('Next :', callback.drag.getPermission('next', treeNodes[0].type, targetNode.type))
                    return callback.drag.getPermission('next', treeNodes[0].type, targetNode.type)
                },

                innerTree: (treeId, treeNodes, targetNode) => {

                    var exist = false;
                    var _targetNode = RED.nodes.node(targetNode.id);
                    if (_targetNode && _targetNode.datapoints) {
                        if (_targetNode.datapoints[treeNodes[0].id]) {
                            exist = true;
                        } else {
                            exist = false;
                        }
                    }

                    Tree.setting.edit.drag.isCopy = callback.drag.getPermission('copy', treeNodes[0].type, targetNode.type);
                    Tree.setting.edit.drag.isMove = callback.drag.getPermission('move', treeNodes[0].type, targetNode.type);
                    return !exist && callback.drag.getPermission('inner', treeNodes[0].type, targetNode.type)
                },
                /*             isCopy: (treeId, treeNodes, targetNode) =>  callback.drag.getPermission('copy', treeNodes[0].type, targetNode.type),
                
                            isMove: (treeId, treeNodes, targetNode) =>  callback.drag.getPermission('move', treeNodes[0].type, targetNode.type), */
            }
        }

        var setting = {
            view: {
                addHoverDom: callback.view.addHoverDom,
                removeHoverDom: callback.view.removeHoverDom,
                dblClickExpand: false,
                showLine: true,
                showIcon: true,
                selectedMulti: false
            },
            edit: {
                enable: true,
                showRemoveBtn: false,
                showRenameBtn: false,
                drag: {
                    prev: callback.drag.prevTree,
                    next: callback.drag.nextTree,
                    inner: callback.drag.innerTree,
                    isCopy: callback.drag.isCopy,
                    isMove: callback.drag.isMove,
                }

            },
            check: {
                enable: false
            },
            data: {
                simpleData: {
                    enable: true
                }
            },
            callback: {
                beforeDrag: callback.general.beforeDrag,
                onNodeCreated: callback.general.onNodeCreated,
                onClick: callback.general.onClick,
                onDblClick: callback.general.onDblClick,
                onRightClick: callback.general.onRightClick,
                onMouseDown: callback.general.onMouseDown,
                onMouseUp: callback.general.onMouseUp,
                onExpand: callback.general.onExpand,
                onCollapse: callback.general.onCollapse,
                onRemove: callback.general.onRemove,
                onDrag: callback.general.onDrag,
                onDragMove: callback.general.onDragMove,
                onDrop: callback.general.onDrop,
            }
        };

        var treelist = RED.settings.get('treelist') ||
            [
                { id: 1, pId: 0, name: "System", open: true, isParent: true, class: 'icon-system' },
                { id: 11, pId: 1, name: "Configuration", class: 'icon-config', isParent: true },
                { id: 12, pId: 1, name: "Data Base", class: 'icon-database', isParent: true },
                { id: 13, pId: 1, name: "Data Point", class: 'icon-datapoint', isParent: true },
                { id: 14, pId: 1, name: "Dashboard", class: 'icon-dashboard', isParent: true },
                { id: 15, pId: 1, name: "Mobile", class: 'icon-mobile', isParent: true },
                { id: 16, pId: 1, name: "Report", class: 'icon-report', isParent: true },
                { id: 17, pId: 1, name: "Extras", class: 'icon-demos', isParent: true },
                { id: 141, pId: 17, name: "Demo 01", class: 'icon-demos', isParent: false },
                { id: 142, pId: 17, name: "Demo 02", class: 'icon-demos', isParent: false },
                { id: 143, pId: 17, name: "Demo 03", class: 'icon-demos', isParent: false },
                { id: 144, pId: 17, name: "Demo 04", class: 'icon-demos', isParent: false },
                { id: 145, pId: 17, name: "Demo 05", class: 'icon-demos', isParent: false },
                { id: 146, pId: 17, name: "Demo 06", class: 'icon-demos', isParent: false },
                { id: 147, pId: 17, name: "Demo 07", class: 'icon-demos', isParent: false },
                { id: 148, pId: 17, name: "Demo 08", class: 'icon-demos', isParent: false },
                { id: 149, pId: 17, name: "Demo 09", class: 'icon-demos', isParent: false },
                { id: 150, pId: 17, name: "Demo 10", class: 'icon-demos', isParent: false },
            ];
        $(`<ul id="xapptreelist" class="ztree" style="margin: 3px;"></ul>`).appendTo(`#red-ui-palette-content`)
        XAPP.trees.init($("#xapptreelist"), setting, treelist);
        Tree = XAPP.trees.tree.getZTreeObj("xapptreelist");


        XAPP.actions.add("core:tree-node-import", actions.importNodes)
        XAPP.actions.add("core:tree-node-export", actions.exportNodes)
        XAPP.actions.add("core:tree-new-database", actions.adddatabase)
        XAPP.actions.add("core:tree-new-tag-archive", actions.addTag)
        XAPP.actions.add("core:tree-new-group", actions.addGroup)

        XAPP.actions.add("core:tree-new-tag-logging", actions.addTagLogging)

        XAPP.actions.add("core:tree-node-refresh", actions.refresh)
        XAPP.actions.add("core:tree-node-cut", actions.cut)
        XAPP.actions.add("core:tree-node-copy", actions.copy)
        XAPP.actions.add("core:tree-node-paste", actions.paste)

        XAPP.actions.add("core:tree-node-delete", actions.remove)


        XAPP.actions.add("core:tree-new-connection", actions.addConnection)


        XAPP.actions.add("core:tree-new-ui-group", actions.adduigroup)
        XAPP.actions.add("core:tree-new-ui-tab", actions.adduitab)

        XAPP.actions.add("core:tree-new-ui-gauge", actions.adduigauge)
        XAPP.actions.add("core:tree-new-ui-chart", actions.adduichart)
        XAPP.actions.add("core:tree-new-ui-toast", actions.adduitoast)
        XAPP.actions.add("core:tree-new-ui-piechart", actions.adduipiechart)
        XAPP.actions.add("core:tree-new-ui-uispark", actions.adduispark)
        XAPP.actions.add("core:tree-new-ui-uiprogressbar", actions.adduiprogressbar)
        XAPP.actions.add("core:tree-new-ui-uiprogressbox", actions.adduiprogressbox)
        XAPP.actions.add("core:tree-new-ui-uiinline", actions.adduiinline)
        XAPP.actions.add("core:tree-new-ui-uiinfobox", actions.adduiinfobox)


        XAPP.actions.add("core:tree-new-ui-barchart", actions.adduibarchart)
        XAPP.actions.add("core:tree-new-ui-template", actions.adduitemplate)
        XAPP.actions.add("core:tree-new-db", actions.adddatabase)

        XAPP.actions.add("core:tree-new-coll", actions.addcollection)

        XAPP.actions.add("core:tree-new-mmobile", actions.addmobile)
        XAPP.actions.add("core:tree-new-mwidget", actions.addmwidget)
        XAPP.actions.add("core:tree-new-mpiechart", actions.addmpiechart)
        XAPP.actions.add("core:tree-new-mbarchart", actions.addmbarchart)

        XAPP.actions.add("core:tree-new-datapoint", actions.adddatapoint)
        XAPP.actions.add("core:tree-new-calculator", actions.addcalculator)

        XAPP.actions.add("core:tree-new-batch", actions.addBatch)
        XAPP.actions.add("core:tree-new-alarm", actions.addAlarm)
        XAPP.actions.add("core:tree-new-status", actions.addStatus)
        XAPP.actions.add("core:tree-new-phase", actions.addPhase)
        XAPP.actions.add("core:tree-new-trend", actions.addTrend)

        XAPP.actions.add("core:tree-new-statemachine", actions.addstatemachine)

        XAPP.actions.add("core:tree-new-rpreport", actions.addrpreport)
        XAPP.actions.add("core:tree-new-rpwidget", actions.addrpwidget)
        XAPP.actions.add("core:tree-new-rptemplate", actions.addrptemplate)
        XAPP.actions.add("core:tree-new-rpchart", actions.addrpchart)
        RED.events.on("editor:save", events.editorsave)
    }
    return {
        init: init,
        actions: actions,
        tree: () => Tree,
    }
})();

XAPP.trees = (function () {
    var tree = (function () {
        var settings = {}, roots = {}, caches = {}, consts = {},
            //default consts of core
            _consts = {
                className: {
                    BUTTON: "button",
                    LEVEL: "level",
                    ICO_LOADING: "ico_loading",
                    SWITCH: "switch",
                    NAME: 'node_name'
                },
                event: {
                    NODECREATED: "ztree_nodeCreated",
                    CLICK: "ztree_click",
                    EXPAND: "ztree_expand",
                    COLLAPSE: "ztree_collapse",
                    ASYNC_SUCCESS: "ztree_async_success",
                    ASYNC_ERROR: "ztree_async_error",
                    REMOVE: "ztree_remove",
                    SELECTED: "ztree_selected",
                    UNSELECTED: "ztree_unselected"
                },
                id: {
                    A: "_a",
                    ICON: "_ico",
                    SPAN: "_span",
                    SWITCH: "_switch",
                    UL: "_ul"
                },
                line: {
                    ROOT: "root",
                    ROOTS: "roots",
                    CENTER: "center",
                    BOTTOM: "bottom",
                    NOLINE: "noline",
                    LINE: "line"
                },
                folder: {
                    OPEN: "open",
                    CLOSE: "close",
                    DOCU: "docu"
                },
                node: {
                    CURSELECTED: "curSelectedNode"
                }
            },
            //default setting of core
            _setting = {
                treeId: "",
                treeObj: null,
                view: {
                    addDiyDom: null,
                    autoCancelSelected: true,
                    dblClickExpand: true,
                    expandSpeed: "fast",
                    fontCss: {},
                    nameIsHTML: false,
                    selectedMulti: true,
                    showIcon: true,
                    showLine: true,
                    showTitle: true,
                    txtSelectedEnable: false
                },
                data: {
                    key: {
                        isParent: "isParent",
                        children: "children",
                        name: "name",
                        title: "",
                        url: "url",
                        icon: "icon"
                    },
                    simpleData: {
                        enable: false,
                        idKey: "id",
                        pIdKey: "pId",
                        rootPId: null
                    },
                    keep: {
                        parent: false,
                        leaf: false
                    }
                },
                async: {
                    enable: false,
                    contentType: "application/x-www-form-urlencoded",
                    type: "post",
                    dataType: "text",
                    headers: {},
                    xhrFields: {},
                    url: "",
                    autoParam: [],
                    otherParam: [],
                    dataFilter: null
                },
                callback: {
                    beforeAsync: null,
                    beforeClick: null,
                    beforeDblClick: null,
                    beforeRightClick: null,
                    beforeMouseDown: null,
                    beforeMouseUp: null,
                    beforeExpand: null,
                    beforeCollapse: null,
                    beforeRemove: null,

                    onAsyncError: null,
                    onAsyncSuccess: null,
                    onNodeCreated: null,
                    onClick: null,
                    onDblClick: null,
                    onRightClick: null,
                    onMouseDown: null,
                    onMouseUp: null,
                    onExpand: null,
                    onCollapse: null,
                    onRemove: null
                }
            };
        //default root of core
        //zTree use root to save full data
        _initRoot = function (setting) {
            var r = data.getRoot(setting);
            if (!r) {
                r = {};
                data.setRoot(setting, r);
            }
            data.nodeChildren(setting, r, []);
            r.expandTriggerFlag = false;
            r.curSelectedList = [];
            r.noSelection = true;
            r.createdNodes = [];
            r.zId = 0;
            r._ver = (new Date()).getTime();
        };
        //default cache of core
        _initCache = function (setting) {
            var c = data.getCache(setting);
            if (!c) {
                c = {};
                data.setCache(setting, c);
            }
            c.nodes = [];
            c.doms = [];
        };
        //default bindEvent of core
        _bindEvent = function (setting) {
            var o = setting.treeObj,
                c = consts.event;
            o.bind(c.NODECREATED, function (event, treeId, node) {
                tools.apply(setting.callback.onNodeCreated, [event, treeId, node]);
            });

            o.bind(c.CLICK, function (event, srcEvent, treeId, node, clickFlag) {
                tools.apply(setting.callback.onClick, [srcEvent, treeId, node, clickFlag]);
            });

            o.bind(c.EXPAND, function (event, treeId, node) {
                tools.apply(setting.callback.onExpand, [event, treeId, node]);
            });

            o.bind(c.COLLAPSE, function (event, treeId, node) {
                tools.apply(setting.callback.onCollapse, [event, treeId, node]);
            });

            o.bind(c.ASYNC_SUCCESS, function (event, treeId, node, msg) {
                tools.apply(setting.callback.onAsyncSuccess, [event, treeId, node, msg]);
            });

            o.bind(c.ASYNC_ERROR, function (event, treeId, node, XMLHttpRequest, textStatus, errorThrown) {
                tools.apply(setting.callback.onAsyncError, [event, treeId, node, XMLHttpRequest, textStatus, errorThrown]);
            });

            o.bind(c.REMOVE, function (event, treeId, treeNode) {
                tools.apply(setting.callback.onRemove, [event, treeId, treeNode]);
            });

            o.bind(c.SELECTED, function (event, treeId, node) {
                tools.apply(setting.callback.onSelected, [treeId, node]);
            });
            o.bind(c.UNSELECTED, function (event, treeId, node) {
                tools.apply(setting.callback.onUnSelected, [treeId, node]);
            });
        };
        _unbindEvent = function (setting) {
            var o = setting.treeObj,
                c = consts.event;
            o.unbind(c.NODECREATED)
                .unbind(c.CLICK)
                .unbind(c.EXPAND)
                .unbind(c.COLLAPSE)
                .unbind(c.ASYNC_SUCCESS)
                .unbind(c.ASYNC_ERROR)
                .unbind(c.REMOVE)
                .unbind(c.SELECTED)
                .unbind(c.UNSELECTED);
        };
        //default event proxy of core
        _eventProxy = function (event) {
            var target = event.target,
                setting = data.getSetting(event.data.treeId),
                tId = "", node = null,
                nodeEventType = "", treeEventType = "",
                nodeEventCallback = null, treeEventCallback = null,
                tmp = null;

            if (tools.eqs(event.type, "mousedown")) {
                treeEventType = "mousedown";
            } else if (tools.eqs(event.type, "mouseup")) {
                treeEventType = "mouseup";
            } else if (tools.eqs(event.type, "contextmenu")) {
                treeEventType = "contextmenu";
            } else if (tools.eqs(event.type, "click")) {
                if (tools.eqs(target.tagName, "span") && target.getAttribute("treeNode" + consts.id.SWITCH) !== null) {
                    tId = tools.getNodeMainDom(target).id;
                    nodeEventType = "switchNode";
                } else {
                    tmp = tools.getMDom(setting, target, [{ tagName: "a", attrName: "treeNode" + consts.id.A }]);
                    if (tmp) {
                        tId = tools.getNodeMainDom(tmp).id;
                        nodeEventType = "clickNode";
                    }
                }
            } else if (tools.eqs(event.type, "dblclick")) {
                treeEventType = "dblclick";
                tmp = tools.getMDom(setting, target, [{ tagName: "a", attrName: "treeNode" + consts.id.A }]);
                if (tmp) {
                    tId = tools.getNodeMainDom(tmp).id;
                    nodeEventType = "switchNode";
                }
            }
            if (treeEventType.length > 0 && tId.length == 0) {
                tmp = tools.getMDom(setting, target, [{ tagName: "a", attrName: "treeNode" + consts.id.A }]);
                if (tmp) {
                    tId = tools.getNodeMainDom(tmp).id;
                }
            }
            // event to node
            if (tId.length > 0) {
                node = data.getNodeCache(setting, tId);
                switch (nodeEventType) {
                    case "switchNode":
                        var isParent = data.nodeIsParent(setting, node);
                        if (!isParent) {
                            nodeEventType = "";
                        } else if (tools.eqs(event.type, "click")
                            || (tools.eqs(event.type, "dblclick") && tools.apply(setting.view.dblClickExpand, [setting.treeId, node], setting.view.dblClickExpand))) {
                            nodeEventCallback = handler.onSwitchNode;
                        } else {
                            nodeEventType = "";
                        }
                        break;
                    case "clickNode":
                        nodeEventCallback = handler.onClickNode;
                        break;
                }
            }
            // event to zTree
            switch (treeEventType) {
                case "mousedown":
                    treeEventCallback = handler.onZTreeMousedown;
                    break;
                case "mouseup":
                    treeEventCallback = handler.onZTreeMouseup;
                    break;
                case "dblclick":
                    treeEventCallback = handler.onZTreeDblclick;
                    break;
                case "contextmenu":
                    treeEventCallback = handler.onZTreeContextmenu;
                    break;
            }
            var proxyResult = {
                stop: false,
                node: node,
                nodeEventType: nodeEventType,
                nodeEventCallback: nodeEventCallback,
                treeEventType: treeEventType,
                treeEventCallback: treeEventCallback
            };
            return proxyResult
        };
        //default init node of core
        _initNode = function (setting, level, n, parentNode, isFirstNode, isLastNode, openFlag) {
            if (!n) return;
            var r = data.getRoot(setting),
                children = data.nodeChildren(setting, n);
            n.level = level;
            n.tId = setting.treeId + "_" + (++r.zId);
            n.parentTId = parentNode ? parentNode.tId : null;
            n.open = (typeof n.open == "string") ? tools.eqs(n.open, "true") : !!n.open;
            var isParent = data.nodeIsParent(setting, n);
            if (tools.isArray(children)) {
                data.nodeIsParent(setting, n, true);
                n.zAsync = true;
            } else {
                isParent = data.nodeIsParent(setting, n, isParent);
                n.open = (isParent && !setting.async.enable) ? n.open : false;
                n.zAsync = !isParent;
            }
            n.isFirstNode = isFirstNode;
            n.isLastNode = isLastNode;
            n.getParentNode = function () {
                return data.getNodeCache(setting, n.parentTId);
            };
            n.getPreNode = function () {
                return data.getPreNode(setting, n);
            };
            n.getNextNode = function () {
                return data.getNextNode(setting, n);
            };
            n.getIndex = function () {
                return data.getNodeIndex(setting, n);
            };
            n.getPath = function () {
                return data.getNodePath(setting, n);
            };
            n.isAjaxing = false;
            data.fixPIdKeyValue(setting, n);
        };
        _init = {
            bind: [_bindEvent],
            unbind: [_unbindEvent],
            caches: [_initCache],
            nodes: [_initNode],
            proxys: [_eventProxy],
            roots: [_initRoot],
            beforeA: [],
            afterA: [],
            innerBeforeA: [],
            innerAfterA: [],
            zTreeTools: []
        };
        //method of operate data
        data = {
            addNodeCache: function (setting, node) {
                data.getCache(setting).nodes[data.getNodeCacheId(node.tId)] = node;
            },
            getNodeCacheId: function (tId) {
                return tId.substring(tId.lastIndexOf("_") + 1);
            },
            addAfterA: function (afterA) {
                _init.afterA.push(afterA);
            },
            addBeforeA: function (beforeA) {
                _init.beforeA.push(beforeA);
            },
            addInnerAfterA: function (innerAfterA) {
                _init.innerAfterA.push(innerAfterA);
            },
            addInnerBeforeA: function (innerBeforeA) {
                _init.innerBeforeA.push(innerBeforeA);
            },
            addInitBind: function (bindEvent) {
                _init.bind.push(bindEvent);
            },
            addInitUnBind: function (unbindEvent) {
                _init.unbind.push(unbindEvent);
            },
            addInitCache: function (initCache) {
                _init.caches.push(initCache);
            },
            addInitNode: function (initNode) {
                _init.nodes.push(initNode);
            },
            addInitProxy: function (initProxy, isFirst) {
                if (!!isFirst) {
                    _init.proxys.splice(0, 0, initProxy);
                } else {
                    _init.proxys.push(initProxy);
                }
            },
            addInitRoot: function (initRoot) {
                _init.roots.push(initRoot);
            },
            addNodesData: function (setting, parentNode, index, nodes) {
                var children = data.nodeChildren(setting, parentNode), params;
                if (!children) {
                    children = data.nodeChildren(setting, parentNode, []);
                    index = -1;
                } else if (index >= children.length) {
                    index = -1;
                }

                if (children.length > 0 && index === 0) {
                    children[0].isFirstNode = false;
                    view.setNodeLineIcos(setting, children[0]);
                } else if (children.length > 0 && index < 0) {
                    children[children.length - 1].isLastNode = false;
                    view.setNodeLineIcos(setting, children[children.length - 1]);
                }
                data.nodeIsParent(setting, parentNode, true);

                if (index < 0) {
                    data.nodeChildren(setting, parentNode, children.concat(nodes));
                } else {
                    params = [index, 0].concat(nodes);
                    children.splice.apply(children, params);
                }
            },
            addSelectedNode: function (setting, node) {
                var root = data.getRoot(setting);
                if (!data.isSelectedNode(setting, node)) {
                    root.curSelectedList.push(node);
                }
            },
            addCreatedNode: function (setting, node) {
                if (!!setting.callback.onNodeCreated || !!setting.view.addDiyDom) {
                    var root = data.getRoot(setting);
                    root.createdNodes.push(node);
                }
            },
            addZTreeTools: function (zTreeTools) {
                _init.zTreeTools.push(zTreeTools);
            },
            exSetting: function (s) {
                $.extend(true, _setting, s);
            },
            fixPIdKeyValue: function (setting, node) {
                if (setting.data.simpleData.enable) {
                    node[setting.data.simpleData.pIdKey] = node.parentTId ? node.getParentNode()[setting.data.simpleData.idKey] : setting.data.simpleData.rootPId;
                }
            },
            getAfterA: function (setting, node, array) {
                for (var i = 0, j = _init.afterA.length; i < j; i++) {
                    _init.afterA[i].apply(this, arguments);
                }
            },
            getBeforeA: function (setting, node, array) {
                for (var i = 0, j = _init.beforeA.length; i < j; i++) {
                    _init.beforeA[i].apply(this, arguments);
                }
            },
            getInnerAfterA: function (setting, node, array) {
                for (var i = 0, j = _init.innerAfterA.length; i < j; i++) {
                    _init.innerAfterA[i].apply(this, arguments);
                }
            },
            getInnerBeforeA: function (setting, node, array) {
                for (var i = 0, j = _init.innerBeforeA.length; i < j; i++) {
                    _init.innerBeforeA[i].apply(this, arguments);
                }
            },
            getCache: function (setting) {
                return caches[setting.treeId];
            },
            getNodeIndex: function (setting, node) {
                if (!node) return null;
                var p = node.parentTId ? node.getParentNode() : data.getRoot(setting),
                    children = data.nodeChildren(setting, p);
                for (var i = 0, l = children.length - 1; i <= l; i++) {
                    if (children[i] === node) {
                        return i;
                    }
                }
                return -1;
            },
            getNextNode: function (setting, node) {
                if (!node) return null;
                var p = node.parentTId ? node.getParentNode() : data.getRoot(setting),
                    children = data.nodeChildren(setting, p);
                for (var i = 0, l = children.length - 1; i <= l; i++) {
                    if (children[i] === node) {
                        return (i == l ? null : children[i + 1]);
                    }
                }
                return null;
            },
            getNodeByParam: function (setting, nodes, key, value) {
                if (!nodes || !key) return null;
                for (var i = 0, l = nodes.length; i < l; i++) {
                    var node = nodes[i];
                    if (node[key] == value) {
                        return nodes[i];
                    }
                    var children = data.nodeChildren(setting, node);
                    var tmp = data.getNodeByParam(setting, children, key, value);
                    if (tmp) return tmp;
                }
                return null;
            },
            getNodeCache: function (setting, tId) {
                if (!tId) return null;
                var n = caches[setting.treeId].nodes[data.getNodeCacheId(tId)];
                return n ? n : null;
            },
            getNodePath: function (setting, node) {
                if (!node) return null;

                var path;
                if (node.parentTId) {
                    path = node.getParentNode().getPath();
                } else {
                    path = [];
                }

                if (path) {
                    path.push(node);
                }

                return path;
            },
            getNodes: function (setting) {
                return data.nodeChildren(setting, data.getRoot(setting));
            },
            getNodesByParam: function (setting, nodes, key, value) {
                if (!nodes || !key) return [];
                var result = [];
                for (var i = 0, l = nodes.length; i < l; i++) {
                    var node = nodes[i];
                    if (node[key] == value) {
                        result.push(node);
                    }
                    var children = data.nodeChildren(setting, node);
                    result = result.concat(data.getNodesByParam(setting, children, key, value));
                }
                return result;
            },
            getNodesByParamFuzzy: function (setting, nodes, key, value) {
                if (!nodes || !key) return [];
                var result = [];
                value = value.toLowerCase();
                for (var i = 0, l = nodes.length; i < l; i++) {
                    var node = nodes[i];
                    if (typeof node[key] == "string" && nodes[i][key].toLowerCase().indexOf(value) > -1) {
                        result.push(node);
                    }
                    var children = data.nodeChildren(setting, node);
                    result = result.concat(data.getNodesByParamFuzzy(setting, children, key, value));
                }
                return result;
            },
            getNodesByFilter: function (setting, nodes, filter, isSingle, invokeParam) {
                if (!nodes) return (isSingle ? null : []);
                var result = isSingle ? null : [];
                for (var i = 0, l = nodes.length; i < l; i++) {
                    var node = nodes[i];
                    if (tools.apply(filter, [node, invokeParam], false)) {
                        if (isSingle) {
                            return node;
                        }
                        result.push(node);
                    }
                    var children = data.nodeChildren(setting, node);
                    var tmpResult = data.getNodesByFilter(setting, children, filter, isSingle, invokeParam);
                    if (isSingle && !!tmpResult) {
                        return tmpResult;
                    }
                    result = isSingle ? tmpResult : result.concat(tmpResult);
                }
                return result;
            },
            getPreNode: function (setting, node) {
                if (!node) return null;
                var p = node.parentTId ? node.getParentNode() : data.getRoot(setting),
                    children = data.nodeChildren(setting, p);
                for (var i = 0, l = children.length; i < l; i++) {
                    if (children[i] === node) {
                        return (i == 0 ? null : children[i - 1]);
                    }
                }
                return null;
            },
            getRoot: function (setting) {
                return setting ? roots[setting.treeId] : null;
            },
            getRoots: function () {
                return roots;
            },
            getSetting: function (treeId) {
                return settings[treeId];
            },
            getSettings: function () {
                return settings;
            },
            getZTreeTools: function (treeId) {
                var r = this.getRoot(this.getSetting(treeId));
                return r ? r.treeTools : null;
            },
            initCache: function (setting) {
                for (var i = 0, j = _init.caches.length; i < j; i++) {
                    _init.caches[i].apply(this, arguments);
                }
            },
            initNode: function (setting, level, node, parentNode, preNode, nextNode) {
                for (var i = 0, j = _init.nodes.length; i < j; i++) {
                    _init.nodes[i].apply(this, arguments);
                }
            },
            initRoot: function (setting) {
                for (var i = 0, j = _init.roots.length; i < j; i++) {
                    _init.roots[i].apply(this, arguments);
                }
            },
            isSelectedNode: function (setting, node) {
                var root = data.getRoot(setting);
                for (var i = 0, j = root.curSelectedList.length; i < j; i++) {
                    if (node === root.curSelectedList[i]) return true;
                }
                return false;
            },
            nodeChildren: function (setting, node, newChildren) {
                if (!node) {
                    return null;
                }
                var key = setting.data.key.children;
                if (typeof newChildren !== 'undefined') {
                    node[key] = newChildren;
                }
                return node[key];
            },
            nodeIsParent: function (setting, node, newIsParent) {
                if (!node) {
                    return false;
                }
                var key = setting.data.key.isParent;
                if (typeof newIsParent !== 'undefined') {
                    if (typeof newIsParent === "string") {
                        newIsParent = tools.eqs(newIsParent, "true");
                    }
                    newIsParent = !!newIsParent;
                    node[key] = newIsParent;
                } else if (typeof node[key] == "string") {
                    node[key] = tools.eqs(node[key], "true");
                } else {
                    node[key] = !!node[key];
                }
                return node[key];
            },
            nodeName: function (setting, node, newName) {
                var key = setting.data.key.name;
                if (typeof newName !== 'undefined') {
                    node[key] = newName;
                }
                return "" + node[key];
            },
            nodeTitle: function (setting, node) {
                var t = setting.data.key.title === "" ? setting.data.key.name : setting.data.key.title;
                return "" + node[t];
            },
            removeNodeCache: function (setting, node) {
                var children = data.nodeChildren(setting, node);
                if (children) {
                    for (var i = 0, l = children.length; i < l; i++) {
                        data.removeNodeCache(setting, children[i]);
                    }
                }
                data.getCache(setting).nodes[data.getNodeCacheId(node.tId)] = null;
            },
            removeSelectedNode: function (setting, node) {
                var root = data.getRoot(setting);
                for (var i = 0, j = root.curSelectedList.length; i < j; i++) {
                    if (node === root.curSelectedList[i] || !data.getNodeCache(setting, root.curSelectedList[i].tId)) {
                        root.curSelectedList.splice(i, 1);
                        setting.treeObj.trigger(consts.event.UNSELECTED, [setting.treeId, node]);
                        i--;
                        j--;
                    }
                }
            },
            setCache: function (setting, cache) {
                caches[setting.treeId] = cache;
            },
            setRoot: function (setting, root) {
                roots[setting.treeId] = root;
            },
            setZTreeTools: function (setting, zTreeTools) {
                for (var i = 0, j = _init.zTreeTools.length; i < j; i++) {
                    _init.zTreeTools[i].apply(this, arguments);
                }
            },
            transformToArrayFormat: function (setting, nodes) {
                if (!nodes) return [];
                var r = [];
                if (tools.isArray(nodes)) {
                    for (var i = 0, l = nodes.length; i < l; i++) {
                        var node = nodes[i];
                        _do(node);
                    }
                } else {
                    _do(nodes);
                }
                return r;

                function _do(_node) {
                    r.push(_node);
                    var children = data.nodeChildren(setting, _node);
                    if (children) {
                        r = r.concat(data.transformToArrayFormat(setting, children));
                    }
                }
            },
            transformTozTreeFormat: function (setting, sNodes) {
                var i, l,
                    key = setting.data.simpleData.idKey,
                    parentKey = setting.data.simpleData.pIdKey;
                if (!key || key == "" || !sNodes) return [];

                if (tools.isArray(sNodes)) {
                    var r = [];
                    var tmpMap = {};
                    for (i = 0, l = sNodes.length; i < l; i++) {
                        tmpMap[sNodes[i][key]] = sNodes[i];
                    }
                    for (i = 0, l = sNodes.length; i < l; i++) {
                        var p = tmpMap[sNodes[i][parentKey]];
                        if (p && sNodes[i][key] != sNodes[i][parentKey]) {
                            var children = data.nodeChildren(setting, p);
                            if (!children) {
                                children = data.nodeChildren(setting, p, []);
                            }
                            children.push(sNodes[i]);
                        } else {
                            r.push(sNodes[i]);
                        }
                    }
                    return r;
                } else {
                    return [sNodes];
                }
            }
        };
        //method of event proxy
        event = {
            bindEvent: function (setting) {
                for (var i = 0, j = _init.bind.length; i < j; i++) {
                    _init.bind[i].apply(this, arguments);
                }
            },
            unbindEvent: function (setting) {
                for (var i = 0, j = _init.unbind.length; i < j; i++) {
                    _init.unbind[i].apply(this, arguments);
                }
            },
            bindTree: function (setting) {
                var eventParam = {
                    treeId: setting.treeId
                },
                    o = setting.treeObj;
                if (!setting.view.txtSelectedEnable) {
                    // for can't select text
                    o.bind('selectstart', handler.onSelectStart).css({
                        "-moz-user-select": "-moz-none"
                    });
                }
                o.bind('click', eventParam, event.proxy);
                o.bind('dblclick', eventParam, event.proxy);
                o.bind('mouseover', eventParam, event.proxy);
                o.bind('mouseout', eventParam, event.proxy);
                o.bind('mousedown', eventParam, event.proxy);
                o.bind('mouseup', eventParam, event.proxy);
                o.bind('contextmenu', eventParam, event.proxy);
            },
            unbindTree: function (setting) {
                var o = setting.treeObj;
                o.unbind('selectstart', handler.onSelectStart)
                    .unbind('click', event.proxy)
                    .unbind('dblclick', event.proxy)
                    .unbind('mouseover', event.proxy)
                    .unbind('mouseout', event.proxy)
                    .unbind('mousedown', event.proxy)
                    .unbind('mouseup', event.proxy)
                    .unbind('contextmenu', event.proxy);
            },
            doProxy: function (e) {
                var results = [];
                for (var i = 0, j = _init.proxys.length; i < j; i++) {
                    var proxyResult = _init.proxys[i].apply(this, arguments);
                    results.push(proxyResult);
                    if (proxyResult.stop) {
                        break;
                    }
                }
                return results;
            },
            proxy: function (e) {
                var setting = data.getSetting(e.data.treeId);
                if (!tools.uCanDo(setting, e)) return true;
                var results = event.doProxy(e),
                    r = true, x = false;
                for (var i = 0, l = results.length; i < l; i++) {
                    var proxyResult = results[i];
                    if (proxyResult.nodeEventCallback) {
                        x = true;
                        r = proxyResult.nodeEventCallback.apply(proxyResult, [e, proxyResult.node]) && r;
                    }
                    if (proxyResult.treeEventCallback) {
                        x = true;
                        r = proxyResult.treeEventCallback.apply(proxyResult, [e, proxyResult.node]) && r;
                    }
                }
                return r;
            }
        };
        //method of event handler
        handler = {
            onSwitchNode: function (event, node) {
                var setting = data.getSetting(event.data.treeId);
                if (node.open) {
                    if (tools.apply(setting.callback.beforeCollapse, [setting.treeId, node], true) == false) return true;
                    data.getRoot(setting).expandTriggerFlag = true;
                    view.switchNode(setting, node);
                } else {
                    if (tools.apply(setting.callback.beforeExpand, [setting.treeId, node], true) == false) return true;
                    data.getRoot(setting).expandTriggerFlag = true;
                    view.switchNode(setting, node);
                }
                return true;
            },
            onClickNode: function (event, node) {
                var setting = data.getSetting(event.data.treeId),
                    clickFlag = ((setting.view.autoCancelSelected && (event.ctrlKey || event.metaKey)) && data.isSelectedNode(setting, node)) ? 0 : (setting.view.autoCancelSelected && (event.ctrlKey || event.metaKey) && setting.view.selectedMulti) ? 2 : 1;
                if (tools.apply(setting.callback.beforeClick, [setting.treeId, node, clickFlag], true) == false) return true;
                if (clickFlag === 0) {
                    view.cancelPreSelectedNode(setting, node);
                } else {
                    view.selectNode(setting, node, clickFlag === 2);
                }
                setting.treeObj.trigger(consts.event.CLICK, [event, setting.treeId, node, clickFlag]);
                return true;
            },
            onZTreeMousedown: function (event, node) {
                var setting = data.getSetting(event.data.treeId);
                if (tools.apply(setting.callback.beforeMouseDown, [setting.treeId, node], true)) {
                    tools.apply(setting.callback.onMouseDown, [event, setting.treeId, node]);
                }
                return true;
            },
            onZTreeMouseup: function (event, node) {
                var setting = data.getSetting(event.data.treeId);
                if (tools.apply(setting.callback.beforeMouseUp, [setting.treeId, node], true)) {
                    tools.apply(setting.callback.onMouseUp, [event, setting.treeId, node]);
                }
                return true;
            },
            onZTreeDblclick: function (event, node) {
                var setting = data.getSetting(event.data.treeId);
                if (tools.apply(setting.callback.beforeDblClick, [setting.treeId, node], true)) {
                    tools.apply(setting.callback.onDblClick, [event, setting.treeId, node]);
                }
                return true;
            },
            onZTreeContextmenu: function (event, node) {
                var setting = data.getSetting(event.data.treeId);
                if (tools.apply(setting.callback.beforeRightClick, [setting.treeId, node], true)) {
                    tools.apply(setting.callback.onRightClick, [event, setting.treeId, node]);
                }
                return (typeof setting.callback.onRightClick) != "function";
            },
            onSelectStart: function (e) {
                var n = e.originalEvent.srcElement.nodeName.toLowerCase();
                return (n === "input" || n === "textarea");
            }
        };
        //method of tools for zTree
        tools = {
            apply: function (fun, param, defaultValue) {
                if ((typeof fun) == "function") {
                    return fun.apply(zt, param ? param : []);
                }
                return defaultValue;
            },
            canAsync: function (setting, node) {
                var children = data.nodeChildren(setting, node);
                var isParent = data.nodeIsParent(setting, node);
                return (setting.async.enable && node && isParent && !(node.zAsync || (children && children.length > 0)));
            },
            clone: function (obj) {
                if (obj === null) return null;
                var o = tools.isArray(obj) ? [] : {};
                for (var i in obj) {
                    o[i] = (obj[i] instanceof Date) ? new Date(obj[i].getTime()) : (typeof obj[i] === "object" ? tools.clone(obj[i]) : obj[i]);
                }
                return o;
            },
            eqs: function (str1, str2) {
                return str1.toLowerCase() === str2.toLowerCase();
            },
            isArray: function (arr) {
                return Object.prototype.toString.apply(arr) === "[object Array]";
            },
            isElement: function (o) {
                return (
                    typeof HTMLElement === "object" ? o instanceof HTMLElement : //DOM2
                        o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string"
                );
            },
            $: function (node, exp, setting) {
                if (!!exp && typeof exp != "string") {
                    setting = exp;
                    exp = "";
                }
                if (typeof node == "string") {
                    return $(node, setting ? setting.treeObj.get(0).ownerDocument : null);
                } else {
                    return $("#" + node.tId + exp, setting ? setting.treeObj : null);
                }
            },
            getMDom: function (setting, curDom, targetExpr) {
                if (!curDom) return null;
                while (curDom && curDom.id !== setting.treeId) {
                    for (var i = 0, l = targetExpr.length; curDom.tagName && i < l; i++) {
                        if (tools.eqs(curDom.tagName, targetExpr[i].tagName) && curDom.getAttribute(targetExpr[i].attrName) !== null) {
                            return curDom;
                        }
                    }
                    curDom = curDom.parentNode;
                }
                return null;
            },
            getNodeMainDom: function (target) {
                return ($(target).parent("li").get(0) || $(target).parentsUntil("li").parent().get(0));
            },
            isChildOrSelf: function (dom, parentId) {
                return ($(dom).closest("#" + parentId).length > 0);
            },
            uCanDo: function (setting, e) {
                return true;
            }
        };
        //method of operate ztree dom
        view = {
            addNodes: function (setting, parentNode, index, newNodes, isSilent) {
                var isParent = data.nodeIsParent(setting, parentNode);
                if (setting.data.keep.leaf && parentNode && !isParent) {
                    return;
                }
                if (!tools.isArray(newNodes)) {
                    newNodes = [newNodes];
                }
                if (setting.data.simpleData.enable) {
                    newNodes = data.transformTozTreeFormat(setting, newNodes);
                }
                if (parentNode) {
                    var target_switchObj = $$(parentNode, consts.id.SWITCH, setting),
                        target_icoObj = $$(parentNode, consts.id.ICON, setting),
                        target_ulObj = $$(parentNode, consts.id.UL, setting);

                    if (!parentNode.open) {
                        view.replaceSwitchClass(parentNode, target_switchObj, consts.folder.CLOSE);
                        view.replaceIcoClass(parentNode, target_icoObj, consts.folder.CLOSE);
                        parentNode.open = false;
                        target_ulObj.css({
                            "display": "none"
                        });
                    }

                    data.addNodesData(setting, parentNode, index, newNodes);
                    view.createNodes(setting, parentNode.level + 1, newNodes, parentNode, index);
                    if (!isSilent) {
                        view.expandCollapseParentNode(setting, parentNode, true);
                    }
                } else {
                    data.addNodesData(setting, data.getRoot(setting), index, newNodes);
                    view.createNodes(setting, 0, newNodes, null, index);
                }
            },
            appendNodes: function (setting, level, nodes, parentNode, index, initFlag, openFlag) {
                if (!nodes) return [];
                var html = [];

                var tmpPNode = (parentNode) ? parentNode : data.getRoot(setting),
                    tmpPChild = data.nodeChildren(setting, tmpPNode),
                    isFirstNode, isLastNode;

                if (!tmpPChild || index >= tmpPChild.length - nodes.length) {
                    index = -1;
                }

                for (var i = 0, l = nodes.length; i < l; i++) {
                    var node = nodes[i];
                    if (initFlag) {
                        isFirstNode = ((index === 0 || tmpPChild.length == nodes.length) && (i == 0));
                        isLastNode = (index < 0 && i == (nodes.length - 1));
                        data.initNode(setting, level, node, parentNode, isFirstNode, isLastNode, openFlag);
                        data.addNodeCache(setting, node);
                    }
                    var isParent = data.nodeIsParent(setting, node);

                    var childHtml = [];
                    var children = data.nodeChildren(setting, node);
                    if (children && children.length > 0) {
                        //make child html first, because checkType
                        childHtml = view.appendNodes(setting, level + 1, children, node, -1, initFlag, openFlag && node.open);
                    }
                    if (openFlag) {
                        view.makeDOMNodeMainBefore(html, setting, node);
                        view.makeDOMNodeLine(html, setting, node);
                        data.getBeforeA(setting, node, html);
                        view.makeDOMNodeNameBefore(html, setting, node);
                        data.getInnerBeforeA(setting, node, html);
                        view.makeDOMNodeIcon(html, setting, node);
                        data.getInnerAfterA(setting, node, html);
                        view.makeDOMNodeNameAfter(html, setting, node);
                        data.getAfterA(setting, node, html);
                        if (isParent && node.open) {
                            view.makeUlHtml(setting, node, html, childHtml.join(''));
                        }
                        view.makeDOMNodeMainAfter(html, setting, node);
                        data.addCreatedNode(setting, node);
                    }
                }
                return html;
            },
            appendParentULDom: function (setting, node) {
                var html = [],
                    nObj = $$(node, setting);
                if (!nObj.get(0) && !!node.parentTId) {
                    view.appendParentULDom(setting, node.getParentNode());
                    nObj = $$(node, setting);
                }
                var ulObj = $$(node, consts.id.UL, setting);
                if (ulObj.get(0)) {
                    ulObj.remove();
                }
                var children = data.nodeChildren(setting, node),
                    childHtml = view.appendNodes(setting, node.level + 1, children, node, -1, false, true);
                view.makeUlHtml(setting, node, html, childHtml.join(''));
                nObj.append(html.join(''));
            },
            asyncNode: function (setting, node, isSilent, callback) {
                var i, l;
                var isParent = data.nodeIsParent(setting, node);
                if (node && !isParent) {
                    tools.apply(callback);
                    return false;
                } else if (node && node.isAjaxing) {
                    return false;
                } else if (tools.apply(setting.callback.beforeAsync, [setting.treeId, node], true) == false) {
                    tools.apply(callback);
                    return false;
                }
                if (node) {
                    node.isAjaxing = true;
                    var icoObj = $$(node, consts.id.ICON, setting);
                    icoObj.attr({ "style": "", "class": consts.className.BUTTON + " " + consts.className.ICO_LOADING });
                }

                var tmpParam = {};
                var autoParam = tools.apply(setting.async.autoParam, [setting.treeId, node], setting.async.autoParam);
                for (i = 0, l = autoParam.length; node && i < l; i++) {
                    var pKey = autoParam[i].split("="), spKey = pKey;
                    if (pKey.length > 1) {
                        spKey = pKey[1];
                        pKey = pKey[0];
                    }
                    tmpParam[spKey] = node[pKey];
                }
                var otherParam = tools.apply(setting.async.otherParam, [setting.treeId, node], setting.async.otherParam);
                if (tools.isArray(otherParam)) {
                    for (i = 0, l = otherParam.length; i < l; i += 2) {
                        tmpParam[otherParam[i]] = otherParam[i + 1];
                    }
                } else {
                    for (var p in otherParam) {
                        tmpParam[p] = otherParam[p];
                    }
                }

                var _tmpV = data.getRoot(setting)._ver;
                $.ajax({
                    contentType: setting.async.contentType,
                    cache: false,
                    type: setting.async.type,
                    url: tools.apply(setting.async.url, [setting.treeId, node], setting.async.url),
                    data: setting.async.contentType.indexOf('application/json') > -1 ? JSON.stringify(tmpParam) : tmpParam,
                    dataType: setting.async.dataType,
                    headers: setting.async.headers,
                    xhrFields: setting.async.xhrFields,
                    success: function (msg) {
                        if (_tmpV != data.getRoot(setting)._ver) {
                            return;
                        }
                        var newNodes = [];
                        try {
                            if (!msg || msg.length == 0) {
                                newNodes = [];
                            } else if (typeof msg == "string") {
                                newNodes = eval("(" + msg + ")");
                            } else {
                                newNodes = msg;
                            }
                        } catch (err) {
                            newNodes = msg;
                        }

                        if (node) {
                            node.isAjaxing = null;
                            node.zAsync = true;
                        }
                        view.setNodeLineIcos(setting, node);
                        if (newNodes && newNodes !== "") {
                            newNodes = tools.apply(setting.async.dataFilter, [setting.treeId, node, newNodes], newNodes);
                            view.addNodes(setting, node, -1, !!newNodes ? tools.clone(newNodes) : [], !!isSilent);
                        } else {
                            view.addNodes(setting, node, -1, [], !!isSilent);
                        }
                        setting.treeObj.trigger(consts.event.ASYNC_SUCCESS, [setting.treeId, node, msg]);
                        tools.apply(callback);
                    },
                    error: function (XMLHttpRequest, textStatus, errorThrown) {
                        if (_tmpV != data.getRoot(setting)._ver) {
                            return;
                        }
                        if (node) node.isAjaxing = null;
                        view.setNodeLineIcos(setting, node);
                        setting.treeObj.trigger(consts.event.ASYNC_ERROR, [setting.treeId, node, XMLHttpRequest, textStatus, errorThrown]);
                    }
                });
                return true;
            },
            cancelPreSelectedNode: function (setting, node, excludeNode) {
                var list = data.getRoot(setting).curSelectedList,
                    i, n;
                for (i = list.length - 1; i >= 0; i--) {
                    n = list[i];
                    if (node === n || (!node && (!excludeNode || excludeNode !== n))) {
                        $$(n, consts.id.A, setting).removeClass(consts.node.CURSELECTED);
                        if (node) {
                            data.removeSelectedNode(setting, node);
                            break;
                        } else {
                            list.splice(i, 1);
                            setting.treeObj.trigger(consts.event.UNSELECTED, [setting.treeId, n]);
                        }
                    }
                }
            },
            createNodeCallback: function (setting) {
                if (!!setting.callback.onNodeCreated || !!setting.view.addDiyDom) {
                    var root = data.getRoot(setting);
                    while (root.createdNodes.length > 0) {
                        var node = root.createdNodes.shift();
                        tools.apply(setting.view.addDiyDom, [setting.treeId, node]);
                        if (!!setting.callback.onNodeCreated) {
                            setting.treeObj.trigger(consts.event.NODECREATED, [setting.treeId, node]);
                        }
                    }
                }
            },
            createNodes: function (setting, level, nodes, parentNode, index) {
                if (!nodes || nodes.length == 0) return;
                var root = data.getRoot(setting),
                    openFlag = !parentNode || parentNode.open || !!$$(data.nodeChildren(setting, parentNode)[0], setting).get(0);
                root.createdNodes = [];
                var zTreeHtml = view.appendNodes(setting, level, nodes, parentNode, index, true, openFlag),
                    parentObj, nextObj;

                if (!parentNode) {
                    parentObj = setting.treeObj;
                    //setting.treeObj.append(zTreeHtml.join(''));
                } else {
                    var ulObj = $$(parentNode, consts.id.UL, setting);
                    if (ulObj.get(0)) {
                        parentObj = ulObj;
                        //ulObj.append(zTreeHtml.join(''));
                    }
                }
                if (parentObj) {
                    if (index >= 0) {
                        nextObj = parentObj.children()[index];
                    }
                    if (index >= 0 && nextObj) {
                        $(nextObj).before(zTreeHtml.join(''));
                    } else {
                        parentObj.append(zTreeHtml.join(''));
                    }
                }

                view.createNodeCallback(setting);
            },
            destroy: function (setting) {
                if (!setting) return;
                data.initCache(setting);
                data.initRoot(setting);
                event.unbindTree(setting);
                event.unbindEvent(setting);
                setting.treeObj.empty();
                delete settings[setting.treeId];
            },
            expandCollapseNode: function (setting, node, expandFlag, animateFlag, callback) {
                var root = data.getRoot(setting);
                var tmpCb, _callback;
                if (!node) {
                    tools.apply(callback, []);
                    return;
                }
                var children = data.nodeChildren(setting, node);
                var isParent = data.nodeIsParent(setting, node);
                if (root.expandTriggerFlag) {
                    _callback = callback;
                    tmpCb = function () {
                        if (_callback) _callback();
                        if (node.open) {
                            setting.treeObj.trigger(consts.event.EXPAND, [setting.treeId, node]);
                        } else {
                            setting.treeObj.trigger(consts.event.COLLAPSE, [setting.treeId, node]);
                        }
                    };
                    callback = tmpCb;
                    root.expandTriggerFlag = false;
                }
                if (!node.open && isParent && ((!$$(node, consts.id.UL, setting).get(0)) || (children && children.length > 0 && !$$(children[0], setting).get(0)))) {
                    view.appendParentULDom(setting, node);
                    view.createNodeCallback(setting);
                }
                if (node.open == expandFlag) {
                    tools.apply(callback, []);
                    return;
                }
                var ulObj = $$(node, consts.id.UL, setting),
                    switchObj = $$(node, consts.id.SWITCH, setting),
                    icoObj = $$(node, consts.id.ICON, setting);

                if (isParent) {
                    node.open = !node.open;
                    if (node.iconOpen && node.iconClose) {
                        icoObj.attr("style", view.makeNodeIcoStyle(setting, node));
                    }

                    if (node.open) {
                        view.replaceSwitchClass(node, switchObj, consts.folder.OPEN);
                        view.replaceIcoClass(node, icoObj, consts.folder.OPEN);
                        if (animateFlag == false || setting.view.expandSpeed == "") {
                            ulObj.show();
                            tools.apply(callback, []);
                        } else {
                            if (children && children.length > 0) {
                                ulObj.slideDown(setting.view.expandSpeed, callback);
                            } else {
                                ulObj.show();
                                tools.apply(callback, []);
                            }
                        }
                    } else {
                        view.replaceSwitchClass(node, switchObj, consts.folder.CLOSE);
                        view.replaceIcoClass(node, icoObj, consts.folder.CLOSE);
                        if (animateFlag == false || setting.view.expandSpeed == "" || !(children && children.length > 0)) {
                            ulObj.hide();
                            tools.apply(callback, []);
                        } else {
                            ulObj.slideUp(setting.view.expandSpeed, callback);
                        }
                    }
                } else {
                    tools.apply(callback, []);
                }
            },
            expandCollapseParentNode: function (setting, node, expandFlag, animateFlag, callback) {
                if (!node) return;
                if (!node.parentTId) {
                    view.expandCollapseNode(setting, node, expandFlag, animateFlag, callback);
                    return;
                } else {
                    view.expandCollapseNode(setting, node, expandFlag, animateFlag);
                }
                if (node.parentTId) {
                    view.expandCollapseParentNode(setting, node.getParentNode(), expandFlag, animateFlag, callback);
                }
            },
            expandCollapseSonNode: function (setting, node, expandFlag, animateFlag, callback) {
                var root = data.getRoot(setting),
                    treeNodes = (node) ? data.nodeChildren(setting, node) : data.nodeChildren(setting, root),
                    selfAnimateSign = (node) ? false : animateFlag,
                    expandTriggerFlag = data.getRoot(setting).expandTriggerFlag;
                data.getRoot(setting).expandTriggerFlag = false;
                if (treeNodes) {
                    for (var i = 0, l = treeNodes.length; i < l; i++) {
                        if (treeNodes[i]) view.expandCollapseSonNode(setting, treeNodes[i], expandFlag, selfAnimateSign);
                    }
                }
                data.getRoot(setting).expandTriggerFlag = expandTriggerFlag;
                view.expandCollapseNode(setting, node, expandFlag, animateFlag, callback);
            },
            isSelectedNode: function (setting, node) {
                if (!node) {
                    return false;
                }
                var list = data.getRoot(setting).curSelectedList,
                    i;
                for (i = list.length - 1; i >= 0; i--) {
                    if (node === list[i]) {
                        return true;
                    }
                }
                return false;
            },
            makeDOMNodeIcon: function (html, setting, node) {
                var nameStr = data.nodeName(setting, node),
                    name = setting.view.nameIsHTML ? nameStr : nameStr.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                var id = '' + node.id
                html.push("<span id='", id.replace('.', '-'), consts.id.ICON,
                    "' title='' treeNode", consts.id.ICON, " class='", id.replace('.', '-'), '_icon ', view.makeNodeIcoClass(setting, node),
                    "' style='", view.makeNodeIcoStyle(setting, node), "'></span><span id='", node.tId, consts.id.SPAN,
                    "' class='", consts.className.NAME,
                    "'>", name, "</span>");
            },
            makeDOMNodeLine: function (html, setting, node) {
                html.push("<span id='", node.tId, consts.id.SWITCH, "' title='' class='", view.makeNodeLineClass(setting, node), "' treeNode", consts.id.SWITCH, "></span>");
            },
            makeDOMNodeMainAfter: function (html, setting, node) {
                html.push("</li>");
            },
            makeDOMNodeMainBefore: function (html, setting, node) {
                html.push("<li id='", node.tId, "' class='", consts.className.LEVEL, node.level, "' tabindex='0' hidefocus='true' treenode>");
            },
            makeDOMNodeNameAfter: function (html, setting, node) {
                html.push("</a>");
            },
            makeDOMNodeNameBefore: function (html, setting, node) {
                var title = data.nodeTitle(setting, node),
                    url = view.makeNodeUrl(setting, node),
                    fontcss = view.makeNodeFontCss(setting, node),
                    fontStyle = [];
                for (var f in fontcss) {
                    fontStyle.push(f, ":", fontcss[f], ";");
                }
                html.push("<a id='", node.tId, consts.id.A, "' class='", consts.className.LEVEL, node.level, "' treeNode", consts.id.A, " onclick=\"", (node.click || ''),
                    "\" ", ((url != null && url.length > 0) ? "href='" + url + "'" : ""), " target='", view.makeNodeTarget(node), "' style='", fontStyle.join(''),
                    "'");
                if (tools.apply(setting.view.showTitle, [setting.treeId, node], setting.view.showTitle) && title) {
                    html.push("title='", title.replace(/'/g, "&#39;").replace(/</g, '&lt;').replace(/>/g, '&gt;'), "'");
                }
                html.push(">");
            },
            makeNodeFontCss: function (setting, node) {
                var fontCss = tools.apply(setting.view.fontCss, [setting.treeId, node], setting.view.fontCss);
                return (fontCss && ((typeof fontCss) != "function")) ? fontCss : {};
            },
            makeNodeIcoClass: function (setting, node) {
                var icoCss = ["ico"];
                if (!node.isAjaxing) {
                    var isParent = data.nodeIsParent(setting, node);
                    icoCss[0] = (node.iconSkin ? node.iconSkin + "_" : "") + icoCss[0];
                    if (isParent) {
                        icoCss.push(node.open ? consts.folder.OPEN : consts.folder.CLOSE);
                    } else {
                        icoCss.push(consts.folder.DOCU);
                    }
                }
                //modif return consts.className.BUTTON + " " + icoCss.join('_');
                return node.class + " " + icoCss.join('_');
            },
            makeNodeIcoStyle: function (setting, node) {
                var icoStyle = [];
                if (!node.isAjaxing) {
                    var isParent = data.nodeIsParent(setting, node);
                    var icon = (isParent && node.iconOpen && node.iconClose) ? (node.open ? node.iconOpen : node.iconClose) : node[setting.data.key.icon];
                    if (icon) icoStyle.push("background:url(", icon, ") 0 0 no-repeat;");
                    if (setting.view.showIcon == false || !tools.apply(setting.view.showIcon, [setting.treeId, node], true)) {
                        icoStyle.push("width:0px;height:0px;");
                    }
                }
                return icoStyle.join('');
            },
            makeNodeLineClass: function (setting, node) {
                var lineClass = [];
                if (setting.view.showLine) {
                    if (node.level == 0 && node.isFirstNode && node.isLastNode) {
                        lineClass.push(consts.line.ROOT);
                    } else if (node.level == 0 && node.isFirstNode) {
                        lineClass.push(consts.line.ROOTS);
                    } else if (node.isLastNode) {
                        lineClass.push(consts.line.BOTTOM);
                    } else {
                        lineClass.push(consts.line.CENTER);
                    }
                } else {
                    lineClass.push(consts.line.NOLINE);
                }
                if (data.nodeIsParent(setting, node)) {
                    lineClass.push(node.open ? consts.folder.OPEN : consts.folder.CLOSE);
                } else {
                    lineClass.push(consts.folder.DOCU);
                }
                return view.makeNodeLineClassEx(node) + lineClass.join('_');
            },
            makeNodeLineClassEx: function (node) {
                return consts.className.BUTTON + " " + consts.className.LEVEL + node.level + " " + consts.className.SWITCH + " ";
            },
            makeNodeTarget: function (node) {
                return (node.target || "_blank");
            },
            makeNodeUrl: function (setting, node) {
                var urlKey = setting.data.key.url;
                return node[urlKey] ? node[urlKey] : null;
            },
            makeUlHtml: function (setting, node, html, content) {
                html.push("<ul id='", node.tId, consts.id.UL, "' class='", consts.className.LEVEL, node.level, " ", view.makeUlLineClass(setting, node), "' style='display:", (node.open ? "block" : "none"), "'>");
                html.push(content);
                html.push("</ul>");
            },
            makeUlLineClass: function (setting, node) {
                return ((setting.view.showLine && !node.isLastNode) ? consts.line.LINE : "");
            },
            removeChildNodes: function (setting, node) {
                if (!node) return;
                var nodes = data.nodeChildren(setting, node);
                if (!nodes) return;

                for (var i = 0, l = nodes.length; i < l; i++) {
                    data.removeNodeCache(setting, nodes[i]);
                }
                data.removeSelectedNode(setting);
                delete node[setting.data.key.children];

                if (!setting.data.keep.parent) {
                    data.nodeIsParent(setting, node, false);
                    node.open = false;
                    var tmp_switchObj = $$(node, consts.id.SWITCH, setting),
                        tmp_icoObj = $$(node, consts.id.ICON, setting);
                    view.replaceSwitchClass(node, tmp_switchObj, consts.folder.DOCU);
                    view.replaceIcoClass(node, tmp_icoObj, consts.folder.DOCU);
                    $$(node, consts.id.UL, setting).remove();
                } else {
                    $$(node, consts.id.UL, setting).empty();
                }
            },
            scrollIntoView: function (setting, dom) {
                if (!dom) {
                    return;
                }
                // support IE 7
                if (typeof Element === 'undefined') {
                    var contRect = setting.treeObj.get(0).getBoundingClientRect(),
                        findMeRect = dom.getBoundingClientRect();
                    if (findMeRect.top < contRect.top || findMeRect.bottom > contRect.bottom
                        || findMeRect.right > contRect.right || findMeRect.left < contRect.left) {
                        dom.scrollIntoView();
                    }
                    return;
                }
                // CC-BY jocki84@googlemail.com, https://gist.github.com/jocki84/6ffafd003387179a988e
                if (!Element.prototype.scrollIntoViewIfNeeded) {
                    Element.prototype.scrollIntoViewIfNeeded = function (centerIfNeeded) {
                        "use strict";

                        function makeRange(start, length) {
                            return { "start": start, "length": length, "end": start + length };
                        }

                        function coverRange(inner, outer) {
                            if (
                                false === centerIfNeeded ||
                                (outer.start < inner.end && inner.start < outer.end)
                            ) {
                                return Math.max(
                                    inner.end - outer.length,
                                    Math.min(outer.start, inner.start)
                                );
                            }
                            return (inner.start + inner.end - outer.length) / 2;
                        }

                        function makePoint(x, y) {
                            return {
                                "x": x,
                                "y": y,
                                "translate": function translate(dX, dY) {
                                    return makePoint(x + dX, y + dY);
                                }
                            };
                        }

                        function absolute(elem, pt) {
                            while (elem) {
                                pt = pt.translate(elem.offsetLeft, elem.offsetTop);
                                elem = elem.offsetParent;
                            }
                            return pt;
                        }

                        var target = absolute(this, makePoint(0, 0)),
                            extent = makePoint(this.offsetWidth, this.offsetHeight),
                            elem = this.parentNode,
                            origin;

                        while (elem instanceof HTMLElement) {
                            // Apply desired scroll amount.
                            origin = absolute(elem, makePoint(elem.clientLeft, elem.clientTop));
                            elem.scrollLeft = coverRange(
                                makeRange(target.x - origin.x, extent.x),
                                makeRange(elem.scrollLeft, elem.clientWidth)
                            );
                            elem.scrollTop = coverRange(
                                makeRange(target.y - origin.y, extent.y),
                                makeRange(elem.scrollTop, elem.clientHeight)
                            );

                            // Determine actual scroll amount by reading back scroll properties.
                            target = target.translate(-elem.scrollLeft, -elem.scrollTop);
                            elem = elem.parentNode;
                        }
                    };
                }
                dom.scrollIntoViewIfNeeded();
            },
            setFirstNode: function (setting, parentNode) {
                var children = data.nodeChildren(setting, parentNode);
                if (children.length > 0) {
                    children[0].isFirstNode = true;
                }
            },
            setLastNode: function (setting, parentNode) {
                var children = data.nodeChildren(setting, parentNode);
                if (children.length > 0) {
                    children[children.length - 1].isLastNode = true;
                }
            },
            removeNode: function (setting, node) {
                var root = data.getRoot(setting),
                    parentNode = (node.parentTId) ? node.getParentNode() : root;

                node.isFirstNode = false;
                node.isLastNode = false;
                node.getPreNode = function () {
                    return null;
                };
                node.getNextNode = function () {
                    return null;
                };

                if (!data.getNodeCache(setting, node.tId)) {
                    return;
                }

                $$(node, setting).remove();
                data.removeNodeCache(setting, node);
                data.removeSelectedNode(setting, node);

                var children = data.nodeChildren(setting, parentNode);
                for (var i = 0, l = children.length; i < l; i++) {
                    if (children[i].tId == node.tId) {
                        children.splice(i, 1);
                        break;
                    }
                }
                view.setFirstNode(setting, parentNode);
                view.setLastNode(setting, parentNode);

                var tmp_ulObj, tmp_switchObj, tmp_icoObj,
                    childLength = children.length;

                //repair nodes old parent
                if (!setting.data.keep.parent && childLength == 0) {
                    //old parentNode has no child nodes
                    data.nodeIsParent(setting, parentNode, false);
                    parentNode.open = false;
                    delete parentNode[setting.data.key.children];
                    tmp_ulObj = $$(parentNode, consts.id.UL, setting);
                    tmp_switchObj = $$(parentNode, consts.id.SWITCH, setting);
                    tmp_icoObj = $$(parentNode, consts.id.ICON, setting);
                    view.replaceSwitchClass(parentNode, tmp_switchObj, consts.folder.DOCU);
                    view.replaceIcoClass(parentNode, tmp_icoObj, consts.folder.DOCU);
                    tmp_ulObj.css("display", "none");

                } else if (setting.view.showLine && childLength > 0) {
                    //old parentNode has child nodes
                    var newLast = children[childLength - 1];
                    tmp_ulObj = $$(newLast, consts.id.UL, setting);
                    tmp_switchObj = $$(newLast, consts.id.SWITCH, setting);
                    tmp_icoObj = $$(newLast, consts.id.ICON, setting);
                    if (parentNode == root) {
                        if (children.length == 1) {
                            //node was root, and ztree has only one root after move node
                            view.replaceSwitchClass(newLast, tmp_switchObj, consts.line.ROOT);
                        } else {
                            var tmp_first_switchObj = $$(children[0], consts.id.SWITCH, setting);
                            view.replaceSwitchClass(children[0], tmp_first_switchObj, consts.line.ROOTS);
                            view.replaceSwitchClass(newLast, tmp_switchObj, consts.line.BOTTOM);
                        }
                    } else {
                        view.replaceSwitchClass(newLast, tmp_switchObj, consts.line.BOTTOM);
                    }
                    tmp_ulObj.removeClass(consts.line.LINE);
                }
            },
            replaceIcoClass: function (node, obj, newName) {
                if (!obj || node.isAjaxing) return;
                var tmpName = obj.attr("class");
                if (tmpName == undefined) return;
                var tmpList = tmpName.split("_");
                switch (newName) {
                    case consts.folder.OPEN:
                    case consts.folder.CLOSE:
                    case consts.folder.DOCU:
                        tmpList[tmpList.length - 1] = newName;
                        break;
                }
                obj.attr("class", tmpList.join("_"));
            },
            replaceSwitchClass: function (node, obj, newName) {
                if (!obj) return;
                var tmpName = obj.attr("class");
                if (tmpName == undefined) return;
                var tmpList = tmpName.split("_");
                switch (newName) {
                    case consts.line.ROOT:
                    case consts.line.ROOTS:
                    case consts.line.CENTER:
                    case consts.line.BOTTOM:
                    case consts.line.NOLINE:
                        tmpList[0] = view.makeNodeLineClassEx(node) + newName;
                        break;
                    case consts.folder.OPEN:
                    case consts.folder.CLOSE:
                    case consts.folder.DOCU:
                        tmpList[1] = newName;
                        break;
                }
                obj.attr("class", tmpList.join("_"));
                if (newName !== consts.folder.DOCU) {
                    obj.removeAttr("disabled");
                } else {
                    obj.attr("disabled", "disabled");
                }
            },
            selectNode: function (setting, node, addFlag) {
                if (!addFlag) {
                    view.cancelPreSelectedNode(setting, null, node);
                }
                $$(node, consts.id.A, setting).addClass(consts.node.CURSELECTED);
                data.addSelectedNode(setting, node);
                setting.treeObj.trigger(consts.event.SELECTED, [setting.treeId, node]);
            },
            setNodeFontCss: function (setting, treeNode) {
                var aObj = $$(treeNode, consts.id.A, setting),
                    fontCss = view.makeNodeFontCss(setting, treeNode);
                if (fontCss) {
                    aObj.css(fontCss);
                }
            },
            setNodeLineIcos: function (setting, node) {
                if (!node) return;
                var switchObj = $$(node, consts.id.SWITCH, setting),
                    ulObj = $$(node, consts.id.UL, setting),
                    icoObj = $$(node, consts.id.ICON, setting),
                    ulLine = view.makeUlLineClass(setting, node);
                if (ulLine.length == 0) {
                    ulObj.removeClass(consts.line.LINE);
                } else {
                    ulObj.addClass(ulLine);
                }
                switchObj.attr("class", view.makeNodeLineClass(setting, node));
                if (data.nodeIsParent(setting, node)) {
                    switchObj.removeAttr("disabled");
                } else {
                    switchObj.attr("disabled", "disabled");
                }
                icoObj.removeAttr("style");
                icoObj.attr("style", view.makeNodeIcoStyle(setting, node));
                icoObj.attr("class", view.makeNodeIcoClass(setting, node));
            },
            setNodeName: function (setting, node) {
                var title = data.nodeTitle(setting, node),
                    nObj = $$(node, consts.id.SPAN, setting);
                nObj.empty();
                if (setting.view.nameIsHTML) {
                    nObj.html(data.nodeName(setting, node));
                } else {
                    nObj.text(data.nodeName(setting, node));
                }
                if (tools.apply(setting.view.showTitle, [setting.treeId, node], setting.view.showTitle)) {
                    var aObj = $$(node, consts.id.A, setting);
                    aObj.attr("title", !title ? "" : title);
                }
            },
            setNodeTarget: function (setting, node) {
                var aObj = $$(node, consts.id.A, setting);
                aObj.attr("target", view.makeNodeTarget(node));
            },
            setNodeUrl: function (setting, node) {
                var aObj = $$(node, consts.id.A, setting),
                    url = view.makeNodeUrl(setting, node);
                if (url == null || url.length == 0) {
                    aObj.removeAttr("href");
                } else {
                    aObj.attr("href", url);
                }
            },
            switchNode: function (setting, node) {
                if (node.open || !tools.canAsync(setting, node)) {
                    view.expandCollapseNode(setting, node, !node.open);
                } else if (setting.async.enable) {
                    if (!view.asyncNode(setting, node)) {
                        view.expandCollapseNode(setting, node, !node.open);
                        return;
                    }
                } else if (node) {
                    view.expandCollapseNode(setting, node, !node.open);
                }
            }
        };

        tree = {
            consts: _consts,
            _z: {
                tools: tools,
                view: view,
                event: event,
                data: data
            },
            getZTreeObj: function (treeId) {
                var o = data.getZTreeTools(treeId);
                return o ? o : null;
            },
            destroy: function (treeId) {
                if (!!treeId && treeId.length > 0) {
                    view.destroy(data.getSetting(treeId));
                } else {
                    for (var s in settings) {
                        view.destroy(settings[s]);
                    }
                }
            },
            init: function (obj, zSetting, zNodes) {
                var setting = tools.clone(_setting);
                $.extend(true, setting, zSetting);
                setting.treeId = obj.attr("id");
                setting.treeObj = obj;
                setting.treeObj.empty();
                settings[setting.treeId] = setting;
                //For some older browser,(e.g., ie6)
                if (typeof document.body.style.maxHeight === "undefined") {
                    setting.view.expandSpeed = "";
                }
                data.initRoot(setting);
                var root = data.getRoot(setting);
                zNodes = zNodes ? tools.clone(tools.isArray(zNodes) ? zNodes : [zNodes]) : [];
                if (setting.data.simpleData.enable) {
                    data.nodeChildren(setting, root, data.transformTozTreeFormat(setting, zNodes));
                } else {
                    data.nodeChildren(setting, root, zNodes);
                }

                data.initCache(setting);
                event.unbindTree(setting);
                event.bindTree(setting);
                event.unbindEvent(setting);
                event.bindEvent(setting);

                var zTreeTools = {
                    setting: setting,
                    addNodes: function (parentNode, index, newNodes, isSilent) {
                        if (!parentNode) parentNode = null;
                        var isParent = data.nodeIsParent(setting, parentNode);
                        if (parentNode && !isParent && setting.data.keep.leaf) return null;

                        var i = parseInt(index, 10);
                        if (isNaN(i)) {
                            isSilent = !!newNodes;
                            newNodes = index;
                            index = -1;
                        } else {
                            index = i;
                        }
                        if (!newNodes) return null;


                        var xNewNodes = tools.clone(tools.isArray(newNodes) ? newNodes : [newNodes]);

                        function addCallback() {
                            view.addNodes(setting, parentNode, index, xNewNodes, (isSilent == true));
                        }

                        if (tools.canAsync(setting, parentNode)) {
                            view.asyncNode(setting, parentNode, isSilent, addCallback);
                        } else {
                            addCallback();
                        }
                        return xNewNodes;
                    },
                    cancelSelectedNode: function (node) {
                        view.cancelPreSelectedNode(setting, node);
                    },
                    destroy: function () {
                        view.destroy(setting);
                    },
                    expandAll: function (expandFlag) {
                        expandFlag = !!expandFlag;
                        view.expandCollapseSonNode(setting, null, expandFlag, true);
                        return expandFlag;
                    },
                    expandNode: function (node, expandFlag, sonSign, focus, callbackFlag) {
                        if (!node || !data.nodeIsParent(setting, node)) return null;
                        if (expandFlag !== true && expandFlag !== false) {
                            expandFlag = !node.open;
                        }
                        callbackFlag = !!callbackFlag;

                        if (callbackFlag && expandFlag && (tools.apply(setting.callback.beforeExpand, [setting.treeId, node], true) == false)) {
                            return null;
                        } else if (callbackFlag && !expandFlag && (tools.apply(setting.callback.beforeCollapse, [setting.treeId, node], true) == false)) {
                            return null;
                        }
                        if (expandFlag && node.parentTId) {
                            view.expandCollapseParentNode(setting, node.getParentNode(), expandFlag, false);
                        }
                        if (expandFlag === node.open && !sonSign) {
                            return null;
                        }

                        data.getRoot(setting).expandTriggerFlag = callbackFlag;
                        if (!tools.canAsync(setting, node) && sonSign) {
                            view.expandCollapseSonNode(setting, node, expandFlag, true, showNodeFocus);
                        } else {
                            node.open = !expandFlag;
                            view.switchNode(this.setting, node);
                            showNodeFocus();
                        }
                        return expandFlag;

                        function showNodeFocus() {
                            var a = $$(node, setting).get(0);
                            if (a && focus !== false) {
                                view.scrollIntoView(setting, a);
                            }
                        }
                    },
                    getNodes: function () {
                        return data.getNodes(setting);
                    },
                    getNodeByParam: function (key, value, parentNode) {
                        if (!key) return null;
                        return data.getNodeByParam(setting, parentNode ? data.nodeChildren(setting, parentNode) : data.getNodes(setting), key, value);
                    },
                    getNodeByTId: function (tId) {
                        return data.getNodeCache(setting, tId);
                    },
                    getNodesByParam: function (key, value, parentNode) {
                        if (!key) return null;
                        return data.getNodesByParam(setting, parentNode ? data.nodeChildren(setting, parentNode) : data.getNodes(setting), key, value);
                    },
                    getNodesByParamFuzzy: function (key, value, parentNode) {
                        if (!key) return null;
                        return data.getNodesByParamFuzzy(setting, parentNode ? data.nodeChildren(setting, parentNode) : data.getNodes(setting), key, value);
                    },
                    getNodesByFilter: function (filter, isSingle, parentNode, invokeParam) {
                        isSingle = !!isSingle;
                        if (!filter || (typeof filter != "function")) return (isSingle ? null : []);
                        return data.getNodesByFilter(setting, parentNode ? data.nodeChildren(setting, parentNode) : data.getNodes(setting), filter, isSingle, invokeParam);
                    },
                    getNodeIndex: function (node) {
                        if (!node) return null;
                        var parentNode = (node.parentTId) ? node.getParentNode() : data.getRoot(setting);
                        var children = data.nodeChildren(setting, parentNode);
                        for (var i = 0, l = children.length; i < l; i++) {
                            if (children[i] == node) return i;
                        }
                        return -1;
                    },
                    getSelectedNodes: function () {
                        var r = [], list = data.getRoot(setting).curSelectedList;
                        for (var i = 0, l = list.length; i < l; i++) {
                            r.push(list[i]);
                        }
                        return r;
                    },
                    getSelectedNode: function () {
                        var selectedNode = zTreeTools.getSelectedNodes()
                        return selectedNode[0];
                    },
                    isSelectedNode: function (node) {
                        return data.isSelectedNode(setting, node);
                    },
                    reAsyncChildNodesPromise: function (parentNode, reloadType, isSilent) {
                        var promise = new Promise(function (resolve, reject) {
                            try {
                                zTreeTools.reAsyncChildNodes(parentNode, reloadType, isSilent, function () {
                                    resolve(parentNode);
                                });
                            } catch (e) {
                                reject(e);
                            }
                        });
                        return promise;
                    },
                    reAsyncChildNodes: function (parentNode, reloadType, isSilent, callback) {
                        if (!this.setting.async.enable) return;
                        var isRoot = !parentNode;
                        if (isRoot) {
                            parentNode = data.getRoot(setting);
                        }
                        if (reloadType == "refresh") {
                            var children = data.nodeChildren(setting, parentNode);
                            for (var i = 0, l = children ? children.length : 0; i < l; i++) {
                                data.removeNodeCache(setting, children[i]);
                            }
                            data.removeSelectedNode(setting);
                            data.nodeChildren(setting, parentNode, []);
                            if (isRoot) {
                                this.setting.treeObj.empty();
                            } else {
                                var ulObj = $$(parentNode, consts.id.UL, setting);
                                ulObj.empty();
                            }
                        }
                        view.asyncNode(this.setting, isRoot ? null : parentNode, !!isSilent, callback);
                    },
                    refresh: function () {
                        this.setting.treeObj.empty();
                        var root = data.getRoot(setting),
                            nodes = data.nodeChildren(setting, root);
                        data.initRoot(setting);
                        data.nodeChildren(setting, root, nodes);
                        data.initCache(setting);
                        view.createNodes(setting, 0, data.nodeChildren(setting, root), null, -1);
                    },
                    removeChildNodes: function (node) {
                        if (!node) return null;
                        var nodes = data.nodeChildren(setting, node);
                        view.removeChildNodes(setting, node);
                        return nodes ? nodes : null;
                    },
                    removeNode: function (node, callbackFlag) {
                        if (!node) return;
                        callbackFlag = !!callbackFlag;
                        if (callbackFlag && tools.apply(setting.callback.beforeRemove, [setting.treeId, node], true) == false) return;
                        view.removeNode(setting, node);
                        if (callbackFlag) {
                            this.setting.treeObj.trigger(consts.event.REMOVE, [setting.treeId, node]);
                        }
                    },
                    selectNode: function (node, addFlag, isSilent) {
                        if (!node) return;
                        if (tools.uCanDo(setting)) {
                            addFlag = setting.view.selectedMulti && addFlag;
                            if (node.parentTId) {
                                view.expandCollapseParentNode(setting, node.getParentNode(), true, false, showNodeFocus);
                            } else if (!isSilent) {
                                try {
                                    $$(node, setting).focus().blur();
                                } catch (e) {
                                }
                            }
                            view.selectNode(setting, node, addFlag);
                        }

                        function showNodeFocus() {
                            if (isSilent) {
                                return;
                            }
                            var a = $$(node, setting).get(0);
                            view.scrollIntoView(setting, a);
                        }
                    },
                    transformTozTreeNodes: function (simpleNodes) {
                        return data.transformTozTreeFormat(setting, simpleNodes);
                    },
                    transformToArray: function (nodes) {
                        return data.transformToArrayFormat(setting, nodes);
                    },
                    updateNode: function (node, checkTypeFlag) {
                        if (!node) return;
                        var nObj = $$(node, setting);
                        if (nObj.get(0) && tools.uCanDo(setting)) {
                            view.setNodeName(setting, node);
                            view.setNodeTarget(setting, node);
                            view.setNodeUrl(setting, node);
                            view.setNodeLineIcos(setting, node);
                            view.setNodeFontCss(setting, node);
                        }
                    }
                };
                root.treeTools = zTreeTools;
                data.setZTreeTools(setting, zTreeTools);
                var children = data.nodeChildren(setting, root);
                if (children && children.length > 0) {
                    view.createNodes(setting, 0, children, null, -1);
                } else if (setting.async.enable && setting.async.url && setting.async.url !== '') {
                    view.asyncNode(setting);
                }
                return zTreeTools;
            },//test

        };
        var zt = tree,
            $$ = tools.$,
            consts = zt.consts;
        return {
            tree: tree,
            consts: consts,
            tools: tools.$
        }
    })();
    //end tree
    var excheck = (function () {
        var _consts = {
            event: {
                CHECK: "ztree_check"
            },
            id: {
                CHECK: "_check"
            },
            checkbox: {
                STYLE: "checkbox",
                DEFAULT: "chk",
                DISABLED: "disable",
                FALSE: "false",
                TRUE: "true",
                FULL: "full",
                PART: "part",
                FOCUS: "focus"
            },
            radio: {
                STYLE: "radio",
                TYPE_ALL: "all",
                TYPE_LEVEL: "level"
            }
        },
            //default setting of excheck
            _setting = {
                check: {
                    enable: false,
                    autoCheckTrigger: false,
                    chkStyle: _consts.checkbox.STYLE,
                    nocheckInherit: false,
                    chkDisabledInherit: false,
                    radioType: _consts.radio.TYPE_LEVEL,
                    chkboxType: {
                        "Y": "ps",
                        "N": "ps"
                    }
                },
                data: {
                    key: {
                        checked: "checked"
                    }
                },
                callback: {
                    beforeCheck: null,
                    onCheck: null
                }
            },
            //default root of excheck
            _initRoot = function (setting) {
                var r = data.getRoot(setting);
                r.radioCheckedList = [];
            },
            //default cache of excheck
            _initCache = function (treeId) {
            },
            //default bind event of excheck
            _bindEvent = function (setting) {
                var o = setting.treeObj,
                    c = consts.event;
                o.bind(c.CHECK, function (event, srcEvent, treeId, node) {
                    event.srcEvent = srcEvent;
                    tools.apply(setting.callback.onCheck, [event, treeId, node]);
                });
            },
            _unbindEvent = function (setting) {
                var o = setting.treeObj,
                    c = consts.event;
                o.unbind(c.CHECK);
            },
            //default event proxy of excheck
            _eventProxy = function (e) {
                var target = e.target,
                    setting = data.getSetting(e.data.treeId),
                    tId = "", node = null,
                    nodeEventType = "", treeEventType = "",
                    nodeEventCallback = null, treeEventCallback = null;

                if (tools.eqs(e.type, "mouseover")) {
                    if (setting.check.enable && tools.eqs(target.tagName, "span") && target.getAttribute("treeNode" + consts.id.CHECK) !== null) {
                        tId = tools.getNodeMainDom(target).id;
                        nodeEventType = "mouseoverCheck";
                    }
                } else if (tools.eqs(e.type, "mouseout")) {
                    if (setting.check.enable && tools.eqs(target.tagName, "span") && target.getAttribute("treeNode" + consts.id.CHECK) !== null) {
                        tId = tools.getNodeMainDom(target).id;
                        nodeEventType = "mouseoutCheck";
                    }
                } else if (tools.eqs(e.type, "click")) {
                    if (setting.check.enable && tools.eqs(target.tagName, "span") && target.getAttribute("treeNode" + consts.id.CHECK) !== null) {
                        tId = tools.getNodeMainDom(target).id;
                        nodeEventType = "checkNode";
                    }
                }
                if (tId.length > 0) {
                    node = data.getNodeCache(setting, tId);
                    switch (nodeEventType) {
                        case "checkNode":
                            nodeEventCallback = _handler.onCheckNode;
                            break;
                        case "mouseoverCheck":
                            nodeEventCallback = _handler.onMouseoverCheck;
                            break;
                        case "mouseoutCheck":
                            nodeEventCallback = _handler.onMouseoutCheck;
                            break;
                    }
                }
                var proxyResult = {
                    stop: nodeEventType === "checkNode",
                    node: node,
                    nodeEventType: nodeEventType,
                    nodeEventCallback: nodeEventCallback,
                    treeEventType: treeEventType,
                    treeEventCallback: treeEventCallback
                };
                return proxyResult
            },
            //default init node of excheck
            _initNode = function (setting, level, n, parentNode, isFirstNode, isLastNode, openFlag) {
                if (!n) return;
                var checked = data.nodeChecked(setting, n);
                n.checkedOld = checked;
                if (typeof n.nocheck == "string") n.nocheck = tools.eqs(n.nocheck, "true");
                n.nocheck = !!n.nocheck || (setting.check.nocheckInherit && parentNode && !!parentNode.nocheck);
                if (typeof n.chkDisabled == "string") n.chkDisabled = tools.eqs(n.chkDisabled, "true");
                n.chkDisabled = !!n.chkDisabled || (setting.check.chkDisabledInherit && parentNode && !!parentNode.chkDisabled);
                if (typeof n.halfCheck == "string") n.halfCheck = tools.eqs(n.halfCheck, "true");
                n.halfCheck = !!n.halfCheck;
                n.check_Child_State = -1;
                n.check_Focus = false;
                n.getCheckStatus = function () {
                    return data.getCheckStatus(setting, n);
                };

                if (setting.check.chkStyle == consts.radio.STYLE && setting.check.radioType == consts.radio.TYPE_ALL && checked) {
                    var r = data.getRoot(setting);
                    r.radioCheckedList.push(n);
                }
            },
            //add dom for check
            _beforeA = function (setting, node, html) {
                if (setting.check.enable) {
                    data.makeChkFlag(setting, node);
                    html.push("<span ID='", node.tId, consts.id.CHECK, "' class='", view.makeChkClass(setting, node), "' treeNode", consts.id.CHECK, (node.nocheck === true ? " style='display:none;'" : ""), "></span>");
                }
            },
            //update zTreeObj, add method of check
            _zTreeTools = function (setting, zTreeTools) {
                zTreeTools.checkNode = function (node, checked, checkTypeFlag, callbackFlag) {
                    var nodeChecked = data.nodeChecked(setting, node);
                    if (node.chkDisabled === true) return;
                    if (checked !== true && checked !== false) {
                        checked = !nodeChecked;
                    }
                    callbackFlag = !!callbackFlag;

                    if (nodeChecked === checked && !checkTypeFlag) {
                        return;
                    } else if (callbackFlag && tools.apply(this.setting.callback.beforeCheck, [this.setting.treeId, node], true) == false) {
                        return;
                    }
                    if (tools.uCanDo(this.setting) && this.setting.check.enable && node.nocheck !== true) {
                        data.nodeChecked(setting, node, checked);
                        var checkObj = $$(node, consts.id.CHECK, this.setting);
                        if (checkTypeFlag || this.setting.check.chkStyle === consts.radio.STYLE) view.checkNodeRelation(this.setting, node);
                        view.setChkClass(this.setting, checkObj, node);
                        view.repairParentChkClassWithSelf(this.setting, node);
                        if (callbackFlag) {
                            this.setting.treeObj.trigger(consts.event.CHECK, [null, this.setting.treeId, node]);
                        }
                    }
                }

                zTreeTools.checkAllNodes = function (checked) {
                    view.repairAllChk(this.setting, !!checked);
                }

                zTreeTools.getCheckedNodes = function (checked) {
                    var checked = (checked !== false);
                    var children = data.nodeChildren(setting, data.getRoot(this.setting));
                    return data.getTreeCheckedNodes(this.setting, children, checked);
                }

                zTreeTools.getChangeCheckedNodes = function () {
                    var children = data.nodeChildren(setting, data.getRoot(this.setting));
                    return data.getTreeChangeCheckedNodes(this.setting, children);
                }

                zTreeTools.setChkDisabled = function (node, disabled, inheritParent, inheritChildren) {
                    disabled = !!disabled;
                    inheritParent = !!inheritParent;
                    inheritChildren = !!inheritChildren;
                    view.repairSonChkDisabled(this.setting, node, disabled, inheritChildren);
                    view.repairParentChkDisabled(this.setting, node.getParentNode(), disabled, inheritParent);
                }

                var _updateNode = zTreeTools.updateNode;
                zTreeTools.updateNode = function (node, checkTypeFlag) {
                    if (_updateNode) _updateNode.apply(zTreeTools, arguments);
                    if (!node || !this.setting.check.enable) return;
                    var nObj = $$(node, this.setting);
                    if (nObj.get(0) && tools.uCanDo(this.setting)) {
                        var checkObj = $$(node, consts.id.CHECK, this.setting);
                        if (checkTypeFlag == true || this.setting.check.chkStyle === consts.radio.STYLE) view.checkNodeRelation(this.setting, node);
                        view.setChkClass(this.setting, checkObj, node);
                        view.repairParentChkClassWithSelf(this.setting, node);
                    }
                }
            },
            //method of operate data
            _data = {
                getRadioCheckedList: function (setting) {
                    var checkedList = data.getRoot(setting).radioCheckedList;
                    for (var i = 0, j = checkedList.length; i < j; i++) {
                        if (!data.getNodeCache(setting, checkedList[i].tId)) {
                            checkedList.splice(i, 1);
                            i--;
                            j--;
                        }
                    }
                    return checkedList;
                },
                getCheckStatus: function (setting, node) {
                    if (!setting.check.enable || node.nocheck || node.chkDisabled) return null;
                    var checked = data.nodeChecked(setting, node),
                        r = {
                            checked: checked,
                            half: node.halfCheck ? node.halfCheck : (setting.check.chkStyle == consts.radio.STYLE ? (node.check_Child_State === 2) : (checked ? (node.check_Child_State > -1 && node.check_Child_State < 2) : (node.check_Child_State > 0)))
                        };
                    return r;
                },
                getTreeCheckedNodes: function (setting, nodes, checked, results) {
                    if (!nodes) return [];
                    var onlyOne = (checked && setting.check.chkStyle == consts.radio.STYLE && setting.check.radioType == consts.radio.TYPE_ALL);
                    results = !results ? [] : results;
                    for (var i = 0, l = nodes.length; i < l; i++) {
                        var node = nodes[i];
                        var children = data.nodeChildren(setting, node);
                        var nodeChecked = data.nodeChecked(setting, node);
                        if (node.nocheck !== true && node.chkDisabled !== true && nodeChecked == checked) {
                            results.push(node);
                            if (onlyOne) {
                                break;
                            }
                        }
                        data.getTreeCheckedNodes(setting, children, checked, results);
                        if (onlyOne && results.length > 0) {
                            break;
                        }
                    }
                    return results;
                },
                getTreeChangeCheckedNodes: function (setting, nodes, results) {
                    if (!nodes) return [];
                    results = !results ? [] : results;
                    for (var i = 0, l = nodes.length; i < l; i++) {
                        var node = nodes[i];
                        var children = data.nodeChildren(setting, node);
                        var nodeChecked = data.nodeChecked(setting, node);
                        if (node.nocheck !== true && node.chkDisabled !== true && nodeChecked != node.checkedOld) {
                            results.push(node);
                        }
                        data.getTreeChangeCheckedNodes(setting, children, results);
                    }
                    return results;
                },
                makeChkFlag: function (setting, node) {
                    if (!node) return;
                    var chkFlag = -1;
                    var children = data.nodeChildren(setting, node);
                    if (children) {
                        for (var i = 0, l = children.length; i < l; i++) {
                            var cNode = children[i];
                            var nodeChecked = data.nodeChecked(setting, cNode);
                            var tmp = -1;
                            if (setting.check.chkStyle == consts.radio.STYLE) {
                                if (cNode.nocheck === true || cNode.chkDisabled === true) {
                                    tmp = cNode.check_Child_State;
                                } else if (cNode.halfCheck === true) {
                                    tmp = 2;
                                } else if (nodeChecked) {
                                    tmp = 2;
                                } else {
                                    tmp = cNode.check_Child_State > 0 ? 2 : 0;
                                }
                                if (tmp == 2) {
                                    chkFlag = 2;
                                    break;
                                } else if (tmp == 0) {
                                    chkFlag = 0;
                                }
                            } else if (setting.check.chkStyle == consts.checkbox.STYLE) {
                                if (cNode.nocheck === true || cNode.chkDisabled === true) {
                                    tmp = cNode.check_Child_State;
                                } else if (cNode.halfCheck === true) {
                                    tmp = 1;
                                } else if (nodeChecked) {
                                    tmp = (cNode.check_Child_State === -1 || cNode.check_Child_State === 2) ? 2 : 1;
                                } else {
                                    tmp = (cNode.check_Child_State > 0) ? 1 : 0;
                                }
                                if (tmp === 1) {
                                    chkFlag = 1;
                                    break;
                                } else if (tmp === 2 && chkFlag > -1 && i > 0 && tmp !== chkFlag) {
                                    chkFlag = 1;
                                    break;
                                } else if (chkFlag === 2 && tmp > -1 && tmp < 2) {
                                    chkFlag = 1;
                                    break;
                                } else if (tmp > -1) {
                                    chkFlag = tmp;
                                }
                            }
                        }
                    }
                    node.check_Child_State = chkFlag;
                }
            },
            //method of event proxy
            _event = {},
            //method of event handler
            _handler = {
                onCheckNode: function (event, node) {
                    if (node.chkDisabled === true) return false;
                    var setting = data.getSetting(event.data.treeId);
                    if (tools.apply(setting.callback.beforeCheck, [setting.treeId, node], true) == false) return true;
                    var nodeChecked = data.nodeChecked(setting, node);
                    data.nodeChecked(setting, node, !nodeChecked);
                    view.checkNodeRelation(setting, node);
                    var checkObj = $$(node, consts.id.CHECK, setting);
                    view.setChkClass(setting, checkObj, node);
                    view.repairParentChkClassWithSelf(setting, node);
                    setting.treeObj.trigger(consts.event.CHECK, [event, setting.treeId, node]);
                    return true;
                },
                onMouseoverCheck: function (event, node) {
                    if (node.chkDisabled === true) return false;
                    var setting = data.getSetting(event.data.treeId),
                        checkObj = $$(node, consts.id.CHECK, setting);
                    node.check_Focus = true;
                    view.setChkClass(setting, checkObj, node);
                    return true;
                },
                onMouseoutCheck: function (event, node) {
                    if (node.chkDisabled === true) return false;
                    var setting = data.getSetting(event.data.treeId),
                        checkObj = $$(node, consts.id.CHECK, setting);
                    node.check_Focus = false;
                    view.setChkClass(setting, checkObj, node);
                    return true;
                }
            },
            //method of tools for zTree
            _tools = {},
            //method of operate ztree dom
            _view = {
                checkNodeRelation: function (setting, node) {
                    var pNode, i, l,
                        r = consts.radio;
                    var nodeChecked = data.nodeChecked(setting, node);
                    if (setting.check.chkStyle == r.STYLE) {
                        var checkedList = data.getRadioCheckedList(setting);
                        if (nodeChecked) {
                            if (setting.check.radioType == r.TYPE_ALL) {
                                for (i = checkedList.length - 1; i >= 0; i--) {
                                    pNode = checkedList[i];
                                    var pNodeChecked = data.nodeChecked(setting, pNode);
                                    if (pNodeChecked && pNode != node) {
                                        data.nodeChecked(setting, pNode, false);
                                        checkedList.splice(i, 1);

                                        view.setChkClass(setting, $$(pNode, consts.id.CHECK, setting), pNode);
                                        if (pNode.parentTId != node.parentTId) {
                                            view.repairParentChkClassWithSelf(setting, pNode);
                                        }
                                    }
                                }
                                checkedList.push(node);
                            } else {
                                var parentNode = (node.parentTId) ? node.getParentNode() : data.getRoot(setting);
                                var children = data.nodeChildren(setting, parentNode);
                                for (i = 0, l = children.length; i < l; i++) {
                                    pNode = children[i];
                                    var pNodeChecked = data.nodeChecked(setting, pNode);
                                    if (pNodeChecked && pNode != node) {
                                        data.nodeChecked(setting, pNode, false);
                                        view.setChkClass(setting, $$(pNode, consts.id.CHECK, setting), pNode);
                                    }
                                }
                            }
                        } else if (setting.check.radioType == r.TYPE_ALL) {
                            for (i = 0, l = checkedList.length; i < l; i++) {
                                if (node == checkedList[i]) {
                                    checkedList.splice(i, 1);
                                    break;
                                }
                            }
                        }

                    } else {
                        var children = data.nodeChildren(setting, node);
                        if (nodeChecked && (!children || children.length == 0 || setting.check.chkboxType.Y.indexOf("s") > -1)) {
                            view.setSonNodeCheckBox(setting, node, true);
                        }
                        if (!nodeChecked && (!children || children.length == 0 || setting.check.chkboxType.N.indexOf("s") > -1)) {
                            view.setSonNodeCheckBox(setting, node, false);
                        }
                        if (nodeChecked && setting.check.chkboxType.Y.indexOf("p") > -1) {
                            view.setParentNodeCheckBox(setting, node, true);
                        }
                        if (!nodeChecked && setting.check.chkboxType.N.indexOf("p") > -1) {
                            view.setParentNodeCheckBox(setting, node, false);
                        }
                    }
                },
                makeChkClass: function (setting, node) {
                    var c = consts.checkbox, r = consts.radio,
                        fullStyle = "";
                    var nodeChecked = data.nodeChecked(setting, node);
                    if (node.chkDisabled === true) {
                        fullStyle = c.DISABLED;
                    } else if (node.halfCheck) {
                        fullStyle = c.PART;
                    } else if (setting.check.chkStyle == r.STYLE) {
                        fullStyle = (node.check_Child_State < 1) ? c.FULL : c.PART;
                    } else {
                        fullStyle = nodeChecked ? ((node.check_Child_State === 2 || node.check_Child_State === -1) ? c.FULL : c.PART) : ((node.check_Child_State < 1) ? c.FULL : c.PART);
                    }
                    var chkName = setting.check.chkStyle + "_" + (nodeChecked ? c.TRUE : c.FALSE) + "_" + fullStyle;
                    chkName = (node.check_Focus && node.chkDisabled !== true) ? chkName + "_" + c.FOCUS : chkName;
                    return consts.className.BUTTON + " " + c.DEFAULT + " " + chkName;
                },
                repairAllChk: function (setting, checked) {
                    if (setting.check.enable && setting.check.chkStyle === consts.checkbox.STYLE) {
                        var root = data.getRoot(setting);
                        var children = data.nodeChildren(setting, root);
                        for (var i = 0, l = children.length; i < l; i++) {
                            var node = children[i];
                            if (node.nocheck !== true && node.chkDisabled !== true) {
                                data.nodeChecked(setting, node, checked);
                            }
                            view.setSonNodeCheckBox(setting, node, checked);
                        }
                    }
                },
                repairChkClass: function (setting, node) {
                    if (!node) return;
                    data.makeChkFlag(setting, node);
                    if (node.nocheck !== true) {
                        var checkObj = $$(node, consts.id.CHECK, setting);
                        view.setChkClass(setting, checkObj, node);
                    }
                },
                repairParentChkClass: function (setting, node) {
                    if (!node || !node.parentTId) return;
                    var pNode = node.getParentNode();
                    view.repairChkClass(setting, pNode);
                    view.repairParentChkClass(setting, pNode);
                },
                repairParentChkClassWithSelf: function (setting, node) {
                    if (!node) return;
                    var children = data.nodeChildren(setting, node);
                    if (children && children.length > 0) {
                        view.repairParentChkClass(setting, children[0]);
                    } else {
                        view.repairParentChkClass(setting, node);
                    }
                },
                repairSonChkDisabled: function (setting, node, chkDisabled, inherit) {
                    if (!node) return;
                    if (node.chkDisabled != chkDisabled) {
                        node.chkDisabled = chkDisabled;
                    }
                    view.repairChkClass(setting, node);
                    var children = data.nodeChildren(setting, node);
                    if (children && inherit) {
                        for (var i = 0, l = children.length; i < l; i++) {
                            var sNode = children[i];
                            view.repairSonChkDisabled(setting, sNode, chkDisabled, inherit);
                        }
                    }
                },
                repairParentChkDisabled: function (setting, node, chkDisabled, inherit) {
                    if (!node) return;
                    if (node.chkDisabled != chkDisabled && inherit) {
                        node.chkDisabled = chkDisabled;
                    }
                    view.repairChkClass(setting, node);
                    view.repairParentChkDisabled(setting, node.getParentNode(), chkDisabled, inherit);
                },
                setChkClass: function (setting, obj, node) {
                    if (!obj) return;
                    if (node.nocheck === true) {
                        obj.hide();
                    } else {
                        obj.show();
                    }
                    obj.attr('class', view.makeChkClass(setting, node));
                },
                setParentNodeCheckBox: function (setting, node, value, srcNode) {
                    var checkObj = $$(node, consts.id.CHECK, setting);
                    if (!srcNode) srcNode = node;
                    data.makeChkFlag(setting, node);
                    if (node.nocheck !== true && node.chkDisabled !== true) {
                        data.nodeChecked(setting, node, value);
                        view.setChkClass(setting, checkObj, node);
                        if (setting.check.autoCheckTrigger && node != srcNode) {
                            setting.treeObj.trigger(consts.event.CHECK, [null, setting.treeId, node]);
                        }
                    }
                    if (node.parentTId) {
                        var pSign = true;
                        if (!value) {
                            var pNodes = data.nodeChildren(setting, node.getParentNode());
                            for (var i = 0, l = pNodes.length; i < l; i++) {
                                var pNode = pNodes[i];
                                var nodeChecked = data.nodeChecked(setting, pNode);
                                if ((pNode.nocheck !== true && pNode.chkDisabled !== true && nodeChecked)
                                    || ((pNode.nocheck === true || pNode.chkDisabled === true) && pNode.check_Child_State > 0)) {
                                    pSign = false;
                                    break;
                                }
                            }
                        }
                        if (pSign) {
                            view.setParentNodeCheckBox(setting, node.getParentNode(), value, srcNode);
                        }
                    }
                },
                setSonNodeCheckBox: function (setting, node, value, srcNode) {
                    if (!node) return;
                    var checkObj = $$(node, consts.id.CHECK, setting);
                    if (!srcNode) srcNode = node;

                    var hasDisable = false;
                    var children = data.nodeChildren(setting, node);
                    if (children) {
                        for (var i = 0, l = children.length; i < l; i++) {
                            var sNode = children[i];
                            view.setSonNodeCheckBox(setting, sNode, value, srcNode);
                            if (sNode.chkDisabled === true) hasDisable = true;
                        }
                    }

                    if (node != data.getRoot(setting) && node.chkDisabled !== true) {
                        if (hasDisable && node.nocheck !== true) {
                            data.makeChkFlag(setting, node);
                        }
                        if (node.nocheck !== true && node.chkDisabled !== true) {
                            data.nodeChecked(setting, node, value);
                            if (!hasDisable) node.check_Child_State = (children && children.length > 0) ? (value ? 2 : 0) : -1;
                        } else {
                            node.check_Child_State = -1;
                        }
                        view.setChkClass(setting, checkObj, node);
                        if (setting.check.autoCheckTrigger && node != srcNode && node.nocheck !== true && node.chkDisabled !== true) {
                            setting.treeObj.trigger(consts.event.CHECK, [null, setting.treeId, node]);
                        }
                    }

                }
            },

            _z = {
                tools: _tools,
                view: _view,
                event: _event,
                data: _data
            };
        $.extend(true, tree.tree.consts, _consts);
        $.extend(true, tree.tree._z, _z);

        var zt = tree.tree,
            tools = zt._z.tools,
            consts = zt.consts,
            view = zt._z.view,
            data = zt._z.data,
            event = zt._z.event,
            $$ = tools.$;

        data.nodeChecked = function (setting, node, newChecked) {
            if (!node) {
                return false;
            }
            var key = setting.data.key.checked;
            if (typeof newChecked !== 'undefined') {
                if (typeof newChecked === "string") {
                    newChecked = tools.eqs(newChecked, "true");
                }
                newChecked = !!newChecked;
                node[key] = newChecked;
            } else if (typeof node[key] == "string") {
                node[key] = tools.eqs(node[key], "true");
            } else {
                node[key] = !!node[key];
            }
            return node[key];
        };

        data.exSetting(_setting);
        data.addInitBind(_bindEvent);
        data.addInitUnBind(_unbindEvent);
        data.addInitCache(_initCache);
        data.addInitNode(_initNode);
        data.addInitProxy(_eventProxy, true);
        data.addInitRoot(_initRoot);
        data.addBeforeA(_beforeA);
        data.addZTreeTools(_zTreeTools);

        var _createNodes = view.createNodes;
        view.createNodes = function (setting, level, nodes, parentNode, index) {
            if (_createNodes) _createNodes.apply(view, arguments);
            if (!nodes) return;
            view.repairParentChkClassWithSelf(setting, parentNode);
        }
        var _removeNode = view.removeNode;
        view.removeNode = function (setting, node) {
            var parentNode = node.getParentNode();
            if (_removeNode) _removeNode.apply(view, arguments);
            if (!node || !parentNode) return;
            view.repairChkClass(setting, parentNode);
            view.repairParentChkClass(setting, parentNode);
        }

        var _appendNodes = view.appendNodes;
        view.appendNodes = function (setting, level, nodes, parentNode, index, initFlag, openFlag) {
            var html = "";
            if (_appendNodes) {
                html = _appendNodes.apply(view, arguments);
            }
            if (parentNode) {
                data.makeChkFlag(setting, parentNode);
            }
            return html;
        }
    })();
    var exedit = (function () {

        var _consts = {
            event: {
                DRAG: "ztree_drag",
                DROP: "ztree_drop",
                RENAME: "ztree_rename",
                DRAGMOVE: "ztree_dragmove"
            },
            id: {
                EDIT: "_edit",
                INPUT: "_input",
                REMOVE: "_remove"
            },
            move: {
                TYPE_INNER: "inner",
                TYPE_PREV: "prev",
                TYPE_NEXT: "next"
            },
            node: {
                CURSELECTED_EDIT: "curSelectedNode_Edit",
                TMPTARGET_TREE: "tmpTargetzTree",
                TMPTARGET_NODE: "tmpTargetNode"
            }
        },
            //default setting of exedit
            _setting = {
                edit: {
                    enable: false,
                    editNameSelectAll: false,
                    showRemoveBtn: true,
                    showRenameBtn: true,
                    removeTitle: "remove",
                    renameTitle: "rename",
                    drag: {
                        autoExpandTrigger: false,
                        isCopy: true,
                        isMove: true,
                        prev: true,
                        next: true,
                        inner: true,
                        minMoveSize: 5,
                        borderMax: 10,
                        borderMin: -5,
                        maxShowNodeNum: 5,
                        autoOpenTime: 500
                    }
                },
                view: {
                    addHoverDom: null,
                    removeHoverDom: null
                },
                callback: {
                    beforeDrag: null,
                    beforeDragOpen: null,
                    beforeDrop: null,
                    beforeEditName: null,
                    beforeRename: null,
                    onDrag: null,
                    onDragMove: null,
                    onDrop: null,
                    onRename: null
                }
            },
            //default root of exedit
            _initRoot = function (setting) {
                var r = data.getRoot(setting), rs = data.getRoots();
                r.curEditNode = null;
                r.curEditInput = null;
                r.curHoverNode = null;
                r.dragFlag = 0;
                r.dragNodeShowBefore = [];
                r.dragMaskList = new Array();
                rs.showHoverDom = true;
            };
        //default cache of exedit
        _initCache = function (treeId) {
        };
        //default bind event of exedit
        _bindEvent = function (setting) {
            var o = setting.treeObj;
            var c = consts.event;
            o.bind(c.RENAME, function (event, treeId, treeNode, isCancel) {
                tools.apply(setting.callback.onRename, [event, treeId, treeNode, isCancel]);
            });

            o.bind(c.DRAG, function (event, srcEvent, treeId, treeNodes) {
                tools.apply(setting.callback.onDrag, [srcEvent, treeId, treeNodes]);
            });

            o.bind(c.DRAGMOVE, function (event, srcEvent, treeId, treeNodes) {
                tools.apply(setting.callback.onDragMove, [srcEvent, treeId, treeNodes]);
            });

            o.bind(c.DROP, function (event, srcEvent, treeId, treeNodes, targetNode, moveType, isCopy) {
                tools.apply(setting.callback.onDrop, [srcEvent, treeId, treeNodes, targetNode, moveType, isCopy]);
            });
        };
        _unbindEvent = function (setting) {
            var o = setting.treeObj;
            var c = consts.event;
            o.unbind(c.RENAME);
            o.unbind(c.DRAG);
            o.unbind(c.DRAGMOVE);
            o.unbind(c.DROP);
        };
        //default event proxy of exedit
        _eventProxy = function (e) {
            var target = e.target,
                setting = data.getSetting(e.data.treeId),
                relatedTarget = e.relatedTarget,
                tId = "", node = null,
                nodeEventType = "", treeEventType = "",
                nodeEventCallback = null, treeEventCallback = null,
                tmp = null;

            if (tools.eqs(e.type, "mouseover")) {
                tmp = tools.getMDom(setting, target, [{ tagName: "a", attrName: "treeNode" + consts.id.A }]);
                if (tmp) {
                    tId = tools.getNodeMainDom(tmp).id;
                    nodeEventType = "hoverOverNode";
                }
            } else if (tools.eqs(e.type, "mouseout")) {
                tmp = tools.getMDom(setting, relatedTarget, [{ tagName: "a", attrName: "treeNode" + consts.id.A }]);
                if (!tmp) {
                    tId = "remove";
                    nodeEventType = "hoverOutNode";
                }
            } else if (tools.eqs(e.type, "mousedown")) {
                tmp = tools.getMDom(setting, target, [{ tagName: "a", attrName: "treeNode" + consts.id.A }]);
                if (tmp) {
                    tId = tools.getNodeMainDom(tmp).id;
                    nodeEventType = "mousedownNode";
                }
            }
            if (tId.length > 0) {
                node = data.getNodeCache(setting, tId);
                switch (nodeEventType) {
                    case "mousedownNode":
                        nodeEventCallback = _handler.onMousedownNode;
                        break;
                    case "hoverOverNode":
                        nodeEventCallback = _handler.onHoverOverNode;
                        break;
                    case "hoverOutNode":
                        nodeEventCallback = _handler.onHoverOutNode;
                        break;
                }
            }
            var proxyResult = {
                stop: false,
                node: node,
                nodeEventType: nodeEventType,
                nodeEventCallback: nodeEventCallback,
                treeEventType: treeEventType,
                treeEventCallback: treeEventCallback
            };
            return proxyResult
        };
        //default init node of exedit
        _initNode = function (setting, level, n, parentNode, isFirstNode, isLastNode, openFlag) {
            if (!n) return;
            n.isHover = false;
            n.editNameFlag = false;
        };
        //update zTreeObj, add method of edit
        _zTreeTools = function (setting, zTreeTools) {
            zTreeTools.cancelEditName = function (newName) {
                var root = data.getRoot(this.setting);
                if (!root.curEditNode) return;
                view.cancelCurEditNode(this.setting, newName ? newName : null, true);
            }
            zTreeTools.copyNode = function (targetNode, node, moveType, isSilent) {
                if (!node) return null;
                var isParent = data.nodeIsParent(setting, targetNode);
                if (targetNode && !isParent && this.setting.data.keep.leaf && moveType === consts.move.TYPE_INNER) return null;
                var _this = this,
                    newNode = tools.clone(node);
                if (!targetNode) {
                    targetNode = null;
                    moveType = consts.move.TYPE_INNER;
                }
                if (moveType == consts.move.TYPE_INNER) {
                    function copyCallback() {
                        view.addNodes(_this.setting, targetNode, -1, [newNode], isSilent);
                    }

                    if (tools.canAsync(this.setting, targetNode)) {
                        view.asyncNode(this.setting, targetNode, isSilent, copyCallback);
                    } else {
                        copyCallback();
                    }
                } else {
                    view.addNodes(this.setting, targetNode.parentNode, -1, [newNode], isSilent);
                    view.moveNode(this.setting, targetNode, newNode, moveType, false, isSilent);
                }
                return newNode;
            }
            zTreeTools.editName = function (node) {
                if (!node || !node.tId || node !== data.getNodeCache(this.setting, node.tId)) return;
                if (node.parentTId) view.expandCollapseParentNode(this.setting, node.getParentNode(), true);
                view.editNode(this.setting, node)
            }
            zTreeTools.moveNode = function (targetNode, node, moveType, isSilent) {
                if (!node) return node;
                var isParent = data.nodeIsParent(setting, targetNode);
                if (targetNode && !isParent && this.setting.data.keep.leaf && moveType === consts.move.TYPE_INNER) {
                    return null;
                } else if (targetNode && ((node.parentTId == targetNode.tId && moveType == consts.move.TYPE_INNER) || $$(node, this.setting).find("#" + targetNode.tId).length > 0)) {
                    return null;
                } else if (!targetNode) {
                    targetNode = null;
                }
                var _this = this;

                function moveCallback() {
                    view.moveNode(_this.setting, targetNode, node, moveType, false, isSilent);
                }

                if (tools.canAsync(this.setting, targetNode) && moveType === consts.move.TYPE_INNER) {
                    view.asyncNode(this.setting, targetNode, isSilent, moveCallback);
                } else {
                    moveCallback();
                }
                return node;
            }
            zTreeTools.setEditable = function (editable) {
                this.setting.edit.enable = editable;
                return this.refresh();
            }
        };
        //method of operate data
        _data = {
            setSonNodeLevel: function (setting, parentNode, node) {
                if (!node) return;
                var children = data.nodeChildren(setting, node);
                node.level = (parentNode) ? parentNode.level + 1 : 0;
                if (!children) return;
                for (var i = 0, l = children.length; i < l; i++) {
                    if (children[i]) data.setSonNodeLevel(setting, node, children[i]);
                }
            }
        };
        //method of event proxy
        _event = {};
        //method of event handler
        _handler = {
            onHoverOverNode: function (event, node) {
                var setting = data.getSetting(event.data.treeId),
                    root = data.getRoot(setting);
                if (root.curHoverNode != node) {
                    _handler.onHoverOutNode(event);
                }
                root.curHoverNode = node;
                view.addHoverDom(setting, node);
            },
            onHoverOutNode: function (event, node) {
                var setting = data.getSetting(event.data.treeId),
                    root = data.getRoot(setting);
                if (root.curHoverNode && !data.isSelectedNode(setting, root.curHoverNode)) {
                    view.removeTreeDom(setting, root.curHoverNode);
                    root.curHoverNode = null;
                }
            },
            onMousedownNode: function (eventMouseDown, _node) {
                var i, l,
                    setting = data.getSetting(eventMouseDown.data.treeId),
                    root = data.getRoot(setting), roots = data.getRoots();
                //right click can't drag & drop
                if (eventMouseDown.button == 2 || !setting.edit.enable || (!setting.edit.drag.isCopy && !setting.edit.drag.isMove)) return true;

                //input of edit node name can't drag & drop
                var target = eventMouseDown.target,
                    _nodes = data.getRoot(setting).curSelectedList,
                    nodes = [];
                if (!data.isSelectedNode(setting, _node)) {
                    nodes = [_node];
                } else {
                    for (i = 0, l = _nodes.length; i < l; i++) {
                        if (_nodes[i].editNameFlag && tools.eqs(target.tagName, "input") && target.getAttribute("treeNode" + consts.id.INPUT) !== null) {
                            return true;
                        }
                        nodes.push(_nodes[i]);
                        if (nodes[0].parentTId !== _nodes[i].parentTId) {
                            nodes = [_node];
                            break;
                        }
                    }
                }

                view.editNodeBlur = true;
                view.cancelCurEditNode(setting);

                var doc = $(setting.treeObj.get(0).ownerDocument),
                    body = $(setting.treeObj.get(0).ownerDocument.body), curNode, tmpArrow, tmpTarget,
                    isOtherTree = false,
                    targetSetting = setting,
                    sourceSetting = setting,
                    preNode, nextNode,
                    preTmpTargetNodeId = null,
                    preTmpMoveType = null,
                    tmpTargetNodeId = null,
                    moveType = consts.move.TYPE_INNER,
                    mouseDownX = eventMouseDown.clientX,
                    mouseDownY = eventMouseDown.clientY,
                    startTime = (new Date()).getTime();

                if (tools.uCanDo(setting)) {
                    doc.bind("mousemove", _docMouseMove);
                }

                function _docMouseMove(event) {
                    //avoid start drag after click node
                    if (root.dragFlag == 0 && Math.abs(mouseDownX - event.clientX) < setting.edit.drag.minMoveSize
                        && Math.abs(mouseDownY - event.clientY) < setting.edit.drag.minMoveSize) {
                        return true;
                    }
                    var i, l, tmpNode, tmpDom, tmpNodes;
                    body.css("cursor", "pointer");

                    if (root.dragFlag == 0) {
                        if (tools.apply(setting.callback.beforeDrag, [setting.treeId, nodes], true) == false) {
                            _docMouseUp(event);
                            return true;
                        }

                        for (i = 0, l = nodes.length; i < l; i++) {
                            if (i == 0) {
                                root.dragNodeShowBefore = [];
                            }
                            tmpNode = nodes[i];
                            if (data.nodeIsParent(setting, tmpNode) && tmpNode.open) {
                                view.expandCollapseNode(setting, tmpNode, !tmpNode.open);
                                root.dragNodeShowBefore[tmpNode.tId] = true;
                            } else {
                                root.dragNodeShowBefore[tmpNode.tId] = false;
                            }
                        }

                        root.dragFlag = 1;
                        roots.showHoverDom = false;
                        tools.showIfameMask(setting, true);

                        //sort
                        var isOrder = true, lastIndex = -1;
                        if (nodes.length > 1) {
                            var pNodes = nodes[0].parentTId ? data.nodeChildren(setting, nodes[0].getParentNode()) : data.getNodes(setting);
                            tmpNodes = [];
                            for (i = 0, l = pNodes.length; i < l; i++) {
                                if (root.dragNodeShowBefore[pNodes[i].tId] !== undefined) {
                                    if (isOrder && lastIndex > -1 && (lastIndex + 1) !== i) {
                                        isOrder = false;
                                    }
                                    tmpNodes.push(pNodes[i]);
                                    lastIndex = i;
                                }
                                if (nodes.length === tmpNodes.length) {
                                    nodes = tmpNodes;
                                    break;
                                }
                            }
                        }
                        if (isOrder) {
                            preNode = nodes[0].getPreNode();
                            nextNode = nodes[nodes.length - 1].getNextNode();
                        }

                        //set node in selected
                        curNode = $$("<ul class='zTreeDragUL'></ul>", setting);
                        for (i = 0, l = nodes.length; i < l; i++) {
                            tmpNode = nodes[i];
                            tmpNode.editNameFlag = false;
                            view.selectNode(setting, tmpNode, i > 0);
                            view.removeTreeDom(setting, tmpNode);

                            if (i > setting.edit.drag.maxShowNodeNum - 1) {
                                continue;
                            }

                            tmpDom = $$("<li id='" + tmpNode.tId + "_tmp'></li>", setting);
                            tmpDom.append($$(tmpNode, consts.id.A, setting).clone());
                            tmpDom.css("padding", "0");
                            tmpDom.children("#" + tmpNode.tId + consts.id.A).removeClass(consts.node.CURSELECTED);
                            curNode.append(tmpDom);
                            if (i == setting.edit.drag.maxShowNodeNum - 1) {
                                tmpDom = $$("<li id='" + tmpNode.tId + "_moretmp'><a>  ...  </a></li>", setting);
                                curNode.append(tmpDom);
                            }
                        }
                        curNode.attr("id", nodes[0].tId + consts.id.UL + "_tmp");
                        curNode.addClass(setting.treeObj.attr("class"));
                        curNode.appendTo(body);

                        tmpArrow = $$("<span class='tmpzTreeMove_arrow'></span>", setting);
                        tmpArrow.attr("id", "zTreeMove_arrow_tmp");
                        tmpArrow.appendTo(body);

                        setting.treeObj.trigger(consts.event.DRAG, [event, setting.treeId, nodes]);
                    }

                    if (root.dragFlag == 1) {
                        if (tmpTarget && tmpArrow.attr("id") == event.target.id && tmpTargetNodeId && (event.clientX + doc.scrollLeft() + 2) > ($("#" + tmpTargetNodeId + consts.id.A, tmpTarget).offset().left)) {
                            var xT = $("#" + tmpTargetNodeId + consts.id.A, tmpTarget);
                            event.target = (xT.length > 0) ? xT.get(0) : event.target;
                        } else if (tmpTarget) {
                            tmpTarget.removeClass(consts.node.TMPTARGET_TREE);
                            if (tmpTargetNodeId) $("#" + tmpTargetNodeId + consts.id.A, tmpTarget).removeClass(consts.node.TMPTARGET_NODE + "_" + consts.move.TYPE_PREV)
                                .removeClass(consts.node.TMPTARGET_NODE + "_" + _consts.move.TYPE_NEXT).removeClass(consts.node.TMPTARGET_NODE + "_" + _consts.move.TYPE_INNER);
                        }
                        tmpTarget = null;
                        tmpTargetNodeId = null;

                        //judge drag & drop in multi ztree
                        isOtherTree = false;
                        targetSetting = setting;
                        var settings = data.getSettings();
                        for (var s in settings) {
                            if (settings[s].treeId && settings[s].edit.enable && settings[s].treeId != setting.treeId
                                && (event.target.id == settings[s].treeId || $(event.target).parents("#" + settings[s].treeId).length > 0)) {
                                isOtherTree = true;
                                targetSetting = settings[s];
                            }
                        }

                        var docScrollTop = doc.scrollTop(),
                            docScrollLeft = doc.scrollLeft(),
                            treeOffset = targetSetting.treeObj.offset(),
                            scrollHeight = targetSetting.treeObj.get(0).scrollHeight,
                            scrollWidth = targetSetting.treeObj.get(0).scrollWidth,
                            dTop = (event.clientY + docScrollTop - treeOffset.top),
                            dBottom = (targetSetting.treeObj.height() + treeOffset.top - event.clientY - docScrollTop),
                            dLeft = (event.clientX + docScrollLeft - treeOffset.left),
                            dRight = (targetSetting.treeObj.width() + treeOffset.left - event.clientX - docScrollLeft),
                            isTop = (dTop < setting.edit.drag.borderMax && dTop > setting.edit.drag.borderMin),
                            isBottom = (dBottom < setting.edit.drag.borderMax && dBottom > setting.edit.drag.borderMin),
                            isLeft = (dLeft < setting.edit.drag.borderMax && dLeft > setting.edit.drag.borderMin),
                            isRight = (dRight < setting.edit.drag.borderMax && dRight > setting.edit.drag.borderMin),
                            isTreeInner = dTop > setting.edit.drag.borderMin && dBottom > setting.edit.drag.borderMin && dLeft > setting.edit.drag.borderMin && dRight > setting.edit.drag.borderMin,
                            isTreeTop = (isTop && targetSetting.treeObj.scrollTop() <= 0),
                            isTreeBottom = (isBottom && (targetSetting.treeObj.scrollTop() + targetSetting.treeObj.height() + 10) >= scrollHeight),
                            isTreeLeft = (isLeft && targetSetting.treeObj.scrollLeft() <= 0),
                            isTreeRight = (isRight && (targetSetting.treeObj.scrollLeft() + targetSetting.treeObj.width() + 10) >= scrollWidth);

                        if (event.target && tools.isChildOrSelf(event.target, targetSetting.treeId)) {
                            //get node <li> dom
                            var targetObj = event.target;
                            while (targetObj && targetObj.tagName && !tools.eqs(targetObj.tagName, "li") && targetObj.id != targetSetting.treeId) {
                                targetObj = targetObj.parentNode;
                            }

                            var canMove = true;
                            //don't move to self or children of self
                            for (i = 0, l = nodes.length; i < l; i++) {
                                tmpNode = nodes[i];
                                if (targetObj.id === tmpNode.tId) {
                                    canMove = false;
                                    break;
                                } else if ($$(tmpNode, setting).find("#" + targetObj.id).length > 0) {
                                    canMove = false;
                                    break;
                                }
                            }
                            if (canMove && event.target && tools.isChildOrSelf(event.target, targetObj.id + consts.id.A)) {
                                tmpTarget = $(targetObj);
                                tmpTargetNodeId = targetObj.id;
                            }
                        }

                        //the mouse must be in zTree
                        tmpNode = nodes[0];
                        if (isTreeInner && tools.isChildOrSelf(event.target, targetSetting.treeId)) {
                            //judge mouse move in root of ztree
                            if (!tmpTarget && (event.target.id == targetSetting.treeId || isTreeTop || isTreeBottom || isTreeLeft || isTreeRight) && (isOtherTree || (!isOtherTree && tmpNode.parentTId))) {
                                tmpTarget = targetSetting.treeObj;
                            }
                            //auto scroll top
                            if (isTop) {
                                targetSetting.treeObj.scrollTop(targetSetting.treeObj.scrollTop() - 10);
                            } else if (isBottom) {
                                targetSetting.treeObj.scrollTop(targetSetting.treeObj.scrollTop() + 10);
                            }
                            if (isLeft) {
                                targetSetting.treeObj.scrollLeft(targetSetting.treeObj.scrollLeft() - 10);
                            } else if (isRight) {
                                targetSetting.treeObj.scrollLeft(targetSetting.treeObj.scrollLeft() + 10);
                            }
                            //auto scroll left
                            if (tmpTarget && tmpTarget != targetSetting.treeObj && tmpTarget.offset().left < targetSetting.treeObj.offset().left) {
                                targetSetting.treeObj.scrollLeft(targetSetting.treeObj.scrollLeft() + tmpTarget.offset().left - targetSetting.treeObj.offset().left);
                            }
                        }

                        curNode.css({
                            "top": (event.clientY + docScrollTop + 3) + "px",
                            "left": (event.clientX + docScrollLeft + 3) + "px"
                        });

                        var dX = 0;
                        var dY = 0;
                        if (tmpTarget && tmpTarget.attr("id") != targetSetting.treeId) {
                            var tmpTargetNode = tmpTargetNodeId == null ? null : data.getNodeCache(targetSetting, tmpTargetNodeId),
                                isCopy = ((event.ctrlKey || event.metaKey) && setting.edit.drag.isMove && setting.edit.drag.isCopy) || (!setting.edit.drag.isMove && setting.edit.drag.isCopy),
                                isPrev = !!(preNode && tmpTargetNodeId === preNode.tId),
                                isNext = !!(nextNode && tmpTargetNodeId === nextNode.tId),
                                isInner = (tmpNode.parentTId && tmpNode.parentTId == tmpTargetNodeId),
                                canPrev = (isCopy || !isNext) && tools.apply(targetSetting.edit.drag.prev, [targetSetting.treeId, nodes, tmpTargetNode], !!targetSetting.edit.drag.prev),
                                canNext = (isCopy || !isPrev) && tools.apply(targetSetting.edit.drag.next, [targetSetting.treeId, nodes, tmpTargetNode], !!targetSetting.edit.drag.next),
                                canInner = (isCopy || !isInner) && !(targetSetting.data.keep.leaf && !data.nodeIsParent(setting, tmpTargetNode)) && tools.apply(targetSetting.edit.drag.inner, [targetSetting.treeId, nodes, tmpTargetNode], !!targetSetting.edit.drag.inner);

                            function clearMove() {
                                tmpTarget = null;
                                tmpTargetNodeId = "";
                                moveType = consts.move.TYPE_INNER;
                                tmpArrow.css({
                                    "display": "none"
                                });
                                if (window.zTreeMoveTimer) {
                                    clearTimeout(window.zTreeMoveTimer);
                                    window.zTreeMoveTargetNodeTId = null
                                }
                            }

                            if (!canPrev && !canNext && !canInner) {
                                clearMove();
                            } else {
                                var tmpTargetA = $("#" + tmpTargetNodeId + consts.id.A, tmpTarget),
                                    tmpNextA = tmpTargetNode.isLastNode ? null : $("#" + tmpTargetNode.getNextNode().tId + consts.id.A, tmpTarget.next()),
                                    tmpTop = tmpTargetA.offset().top,
                                    tmpLeft = tmpTargetA.offset().left,
                                    prevPercent = canPrev ? (canInner ? 0.25 : (canNext ? 0.5 : 1)) : -1,
                                    nextPercent = canNext ? (canInner ? 0.75 : (canPrev ? 0.5 : 0)) : -1,
                                    dY_percent = (event.clientY + docScrollTop - tmpTop) / tmpTargetA.height();

                                if ((prevPercent == 1 || dY_percent <= prevPercent && dY_percent >= -.2) && canPrev) {
                                    dX = 1 - tmpArrow.width();
                                    dY = tmpTop - tmpArrow.height() / 2;
                                    moveType = consts.move.TYPE_PREV;
                                } else if ((nextPercent == 0 || dY_percent >= nextPercent && dY_percent <= 1.2) && canNext) {
                                    dX = 1 - tmpArrow.width();
                                    dY = (tmpNextA == null || (data.nodeIsParent(setting, tmpTargetNode) && tmpTargetNode.open)) ? (tmpTop + tmpTargetA.height() - tmpArrow.height() / 2) : (tmpNextA.offset().top - tmpArrow.height() / 2);
                                    moveType = consts.move.TYPE_NEXT;
                                } else if (canInner) {
                                    dX = 5 - tmpArrow.width();
                                    dY = tmpTop;
                                    moveType = consts.move.TYPE_INNER;
                                } else {
                                    clearMove();
                                }

                                if (tmpTarget) {
                                    tmpArrow.css({
                                        "display": "block",
                                        "top": dY + "px",
                                        "left": (tmpLeft + dX) + "px"
                                    });
                                    tmpTargetA.addClass(consts.node.TMPTARGET_NODE + "_" + moveType);

                                    if (preTmpTargetNodeId != tmpTargetNodeId || preTmpMoveType != moveType) {
                                        startTime = (new Date()).getTime();
                                    }
                                    if (tmpTargetNode && data.nodeIsParent(setting, tmpTargetNode) && moveType == consts.move.TYPE_INNER) {
                                        var startTimer = true;
                                        if (window.zTreeMoveTimer && window.zTreeMoveTargetNodeTId !== tmpTargetNode.tId) {
                                            clearTimeout(window.zTreeMoveTimer);
                                            window.zTreeMoveTargetNodeTId = null;
                                        } else if (window.zTreeMoveTimer && window.zTreeMoveTargetNodeTId === tmpTargetNode.tId) {
                                            startTimer = false;
                                        }
                                        if (startTimer) {
                                            window.zTreeMoveTimer = setTimeout(function () {
                                                if (moveType != consts.move.TYPE_INNER) return;
                                                if (tmpTargetNode && data.nodeIsParent(setting, tmpTargetNode) && !tmpTargetNode.open && (new Date()).getTime() - startTime > targetSetting.edit.drag.autoOpenTime
                                                    && tools.apply(targetSetting.callback.beforeDragOpen, [targetSetting.treeId, tmpTargetNode], true)) {
                                                    view.switchNode(targetSetting, tmpTargetNode);
                                                    if (targetSetting.edit.drag.autoExpandTrigger) {
                                                        targetSetting.treeObj.trigger(consts.event.EXPAND, [targetSetting.treeId, tmpTargetNode]);
                                                    }
                                                }
                                            }, targetSetting.edit.drag.autoOpenTime + 50);
                                            window.zTreeMoveTargetNodeTId = tmpTargetNode.tId;
                                        }
                                    }
                                }
                            }
                        } else {
                            moveType = consts.move.TYPE_INNER;
                            if (tmpTarget && tools.apply(targetSetting.edit.drag.inner, [targetSetting.treeId, nodes, null], !!targetSetting.edit.drag.inner)) {
                                tmpTarget.addClass(consts.node.TMPTARGET_TREE);
                            } else {
                                tmpTarget = null;
                            }
                            tmpArrow.css({
                                "display": "none"
                            });
                            if (window.zTreeMoveTimer) {
                                clearTimeout(window.zTreeMoveTimer);
                                window.zTreeMoveTargetNodeTId = null;
                            }
                        }
                        preTmpTargetNodeId = tmpTargetNodeId;
                        preTmpMoveType = moveType;

                        setting.treeObj.trigger(consts.event.DRAGMOVE, [event, setting.treeId, nodes]);
                    }
                    return false;
                }

                doc.bind("mouseup", _docMouseUp);

                function _docMouseUp(event) {
                    if (window.zTreeMoveTimer) {
                        clearTimeout(window.zTreeMoveTimer);
                        window.zTreeMoveTargetNodeTId = null;
                    }
                    preTmpTargetNodeId = null;
                    preTmpMoveType = null;
                    doc.unbind("mousemove", _docMouseMove);
                    doc.unbind("mouseup", _docMouseUp);
                    doc.unbind("selectstart", _docSelect);
                    body.css("cursor", "");
                    if (tmpTarget) {
                        tmpTarget.removeClass(consts.node.TMPTARGET_TREE);
                        if (tmpTargetNodeId) $("#" + tmpTargetNodeId + consts.id.A, tmpTarget).removeClass(consts.node.TMPTARGET_NODE + "_" + consts.move.TYPE_PREV)
                            .removeClass(consts.node.TMPTARGET_NODE + "_" + _consts.move.TYPE_NEXT).removeClass(consts.node.TMPTARGET_NODE + "_" + _consts.move.TYPE_INNER);
                    }
                    tools.showIfameMask(setting, false);

                    roots.showHoverDom = true;
                    if (root.dragFlag == 0) return;
                    root.dragFlag = 0;

                    var i, l, tmpNode;
                    for (i = 0, l = nodes.length; i < l; i++) {
                        tmpNode = nodes[i];
                        if (data.nodeIsParent(setting, tmpNode) && root.dragNodeShowBefore[tmpNode.tId] && !tmpNode.open) {
                            view.expandCollapseNode(setting, tmpNode, !tmpNode.open);
                            delete root.dragNodeShowBefore[tmpNode.tId];
                        }
                    }

                    if (curNode) curNode.remove();
                    if (tmpArrow) tmpArrow.remove();

                    var isCopy = ((event.ctrlKey || event.metaKey) && setting.edit.drag.isMove && setting.edit.drag.isCopy) || (!setting.edit.drag.isMove && setting.edit.drag.isCopy);
                    if (!isCopy && tmpTarget && tmpTargetNodeId && nodes[0].parentTId && tmpTargetNodeId == nodes[0].parentTId && moveType == consts.move.TYPE_INNER) {
                        tmpTarget = null;
                    }
                    if (tmpTarget) {
                        var dragTargetNode = tmpTargetNodeId == null ? null : data.getNodeCache(targetSetting, tmpTargetNodeId);
                        if (tools.apply(setting.callback.beforeDrop, [targetSetting.treeId, nodes, dragTargetNode, moveType, isCopy], true) == false) {
                            view.selectNodes(sourceSetting, nodes);
                            return;
                        }
                        var newNodes = isCopy ? tools.clone(nodes) : nodes;

                        function dropCallback() {
                            if (isOtherTree) {
                                if (!isCopy) {
                                    for (var i = 0, l = nodes.length; i < l; i++) {
                                        view.removeNode(setting, nodes[i]);
                                    }
                                }
                                if (moveType == consts.move.TYPE_INNER) {
                                    view.addNodes(targetSetting, dragTargetNode, -1, newNodes);
                                } else {
                                    view.addNodes(targetSetting, dragTargetNode.getParentNode(), moveType == consts.move.TYPE_PREV ? dragTargetNode.getIndex() : dragTargetNode.getIndex() + 1, newNodes);
                                }
                            } else {
                                if (isCopy && moveType == consts.move.TYPE_INNER) {
                                    view.addNodes(targetSetting, dragTargetNode, -1, newNodes);
                                } else if (isCopy) {
                                    view.addNodes(targetSetting, dragTargetNode.getParentNode(), moveType == consts.move.TYPE_PREV ? dragTargetNode.getIndex() : dragTargetNode.getIndex() + 1, newNodes);
                                } else {
                                    if (moveType != consts.move.TYPE_NEXT) {
                                        for (i = 0, l = newNodes.length; i < l; i++) {
                                            view.moveNode(targetSetting, dragTargetNode, newNodes[i], moveType, false);
                                        }
                                    } else {
                                        for (i = -1, l = newNodes.length - 1; i < l; l--) {
                                            view.moveNode(targetSetting, dragTargetNode, newNodes[l], moveType, false);
                                        }
                                    }
                                }
                            }
                            view.selectNodes(targetSetting, newNodes);

                            var a = $$(newNodes[0], setting).get(0);
                            view.scrollIntoView(setting, a);

                            setting.treeObj.trigger(consts.event.DROP, [event, targetSetting.treeId, newNodes, dragTargetNode, moveType, isCopy]);
                        }

                        if (moveType == consts.move.TYPE_INNER && tools.canAsync(targetSetting, dragTargetNode)) {
                            view.asyncNode(targetSetting, dragTargetNode, false, dropCallback);
                        } else {
                            dropCallback();
                        }

                    } else {
                        view.selectNodes(sourceSetting, nodes);
                        setting.treeObj.trigger(consts.event.DROP, [event, setting.treeId, nodes, null, null, null]);
                    }
                }

                doc.bind("selectstart", _docSelect);

                function _docSelect() {
                    return false;
                }

                // 2018-03-30 FireFox has fixed this issue.
                //Avoid FireFox's Bug
                //If zTree Div CSS set 'overflow', so drag node outside of zTree, and event.target is error.
                // if(eventMouseDown.preventDefault) {
                // 	eventMouseDown.preventDefault();
                // }
                return true;
            }
        };
        //method of tools for zTree
        _tools = {
            getAbs: function (obj) {
                var oRect = obj.getBoundingClientRect(),
                    scrollTop = document.body.scrollTop + document.documentElement.scrollTop,
                    scrollLeft = document.body.scrollLeft + document.documentElement.scrollLeft;
                return [oRect.left + scrollLeft, oRect.top + scrollTop];
            },
            inputFocus: function (inputObj) {
                if (inputObj.get(0)) {
                    inputObj.focus();
                    tools.setCursorPosition(inputObj.get(0), inputObj.val().length);
                }
            },
            inputSelect: function (inputObj) {
                if (inputObj.get(0)) {
                    inputObj.focus();
                    inputObj.select();
                }
            },
            setCursorPosition: function (obj, pos) {
                if (obj.setSelectionRange) {
                    obj.focus();
                    obj.setSelectionRange(pos, pos);
                } else if (obj.createTextRange) {
                    var range = obj.createTextRange();
                    range.collapse(true);
                    range.moveEnd('character', pos);
                    range.moveStart('character', pos);
                    range.select();
                }
            },
            showIfameMask: function (setting, showSign) {
                var root = data.getRoot(setting);
                //clear full mask
                while (root.dragMaskList.length > 0) {
                    root.dragMaskList[0].remove();
                    root.dragMaskList.shift();
                }
                if (showSign) {
                    //show mask
                    var iframeList = $$("iframe", setting);
                    for (var i = 0, l = iframeList.length; i < l; i++) {
                        var obj = iframeList.get(i),
                            r = tools.getAbs(obj),
                            dragMask = $$("<div id='zTreeMask_" + i + "' class='zTreeMask' style='top:" + r[1] + "px; left:" + r[0] + "px; width:" + obj.offsetWidth + "px; height:" + obj.offsetHeight + "px;'></div>", setting);
                        dragMask.appendTo($$("body", setting));
                        root.dragMaskList.push(dragMask);
                    }
                }
            }
        };
        //method of operate ztree dom
        _view = {
            addEditBtn: function (setting, node) {
                if (node.editNameFlag || $$(node, consts.id.EDIT, setting).length > 0) {
                    return;
                }
                if (!tools.apply(setting.edit.showRenameBtn, [setting.treeId, node], setting.edit.showRenameBtn)) {
                    return;
                }
                var aObj = $$(node, consts.id.A, setting),
                    editStr = "<span class='" + consts.className.BUTTON + " edit' id='" + node.tId + consts.id.EDIT + "' title='" + tools.apply(setting.edit.renameTitle, [setting.treeId, node], setting.edit.renameTitle) + "' treeNode" + consts.id.EDIT + " style='display:none;'></span>";
                aObj.append(editStr);

                $$(node, consts.id.EDIT, setting).bind('click',
                    function () {
                        if (!tools.uCanDo(setting) || tools.apply(setting.callback.beforeEditName, [setting.treeId, node], true) == false) return false;
                        view.editNode(setting, node);
                        return false;
                    }
                ).show();
            },
            addRemoveBtn: function (setting, node) {
                if (node.editNameFlag || $$(node, consts.id.REMOVE, setting).length > 0) {
                    return;
                }
                if (!tools.apply(setting.edit.showRemoveBtn, [setting.treeId, node], setting.edit.showRemoveBtn)) {
                    return;
                }
                var aObj = $$(node, consts.id.A, setting),
                    removeStr = "<span class='" + consts.className.BUTTON + " remove' id='" + node.tId + consts.id.REMOVE + "' title='" + tools.apply(setting.edit.removeTitle, [setting.treeId, node], setting.edit.removeTitle) + "' treeNode" + consts.id.REMOVE + " style='display:none;'></span>";
                aObj.append(removeStr);

                $$(node, consts.id.REMOVE, setting).bind('click',
                    function () {
                        if (!tools.uCanDo(setting) || tools.apply(setting.callback.beforeRemove, [setting.treeId, node], true) == false) return false;
                        view.removeNode(setting, node);
                        setting.treeObj.trigger(consts.event.REMOVE, [setting.treeId, node]);
                        return false;
                    }
                ).bind('mousedown',
                    function (eventMouseDown) {
                        return true;
                    }
                ).show();
            },
            addHoverDom: function (setting, node) {
                if (data.getRoots().showHoverDom) {
                    node.isHover = true;
                    if (setting.edit.enable) {
                        view.addEditBtn(setting, node);
                        view.addRemoveBtn(setting, node);
                    }
                    tools.apply(setting.view.addHoverDom, [setting.treeId, node]);
                }
            },
            cancelCurEditNode: function (setting, forceName, isCancel) {
                var root = data.getRoot(setting),
                    node = root.curEditNode;

                if (node) {
                    var inputObj = root.curEditInput,
                        newName = forceName ? forceName : (isCancel ? data.nodeName(setting, node) : inputObj.val());
                    if (tools.apply(setting.callback.beforeRename, [setting.treeId, node, newName, isCancel], true) === false) {
                        return false;
                    }
                    data.nodeName(setting, node, newName);
                    var aObj = $$(node, consts.id.A, setting);
                    aObj.removeClass(consts.node.CURSELECTED_EDIT);
                    inputObj.unbind();
                    view.setNodeName(setting, node);
                    node.editNameFlag = false;
                    root.curEditNode = null;
                    root.curEditInput = null;
                    view.selectNode(setting, node, false);
                    setting.treeObj.trigger(consts.event.RENAME, [setting.treeId, node, isCancel]);
                }
                root.noSelection = true;
                return true;
            },
            editNode: function (setting, node) {
                var root = data.getRoot(setting);
                view.editNodeBlur = false;
                if (data.isSelectedNode(setting, node) && root.curEditNode == node && node.editNameFlag) {
                    setTimeout(function () {
                        tools.inputFocus(root.curEditInput);
                    }, 0);
                    return;
                }
                node.editNameFlag = true;
                view.removeTreeDom(setting, node);
                view.cancelCurEditNode(setting);
                view.selectNode(setting, node, false);
                $$(node, consts.id.SPAN, setting).html("<input type=text class='rename' id='" + node.tId + consts.id.INPUT + "' treeNode" + consts.id.INPUT + " >");
                var inputObj = $$(node, consts.id.INPUT, setting);
                inputObj.attr("value", data.nodeName(setting, node));
                if (setting.edit.editNameSelectAll) {
                    tools.inputSelect(inputObj);
                } else {
                    tools.inputFocus(inputObj);
                }

                inputObj.bind('blur', function (event) {
                    if (!view.editNodeBlur) {
                        view.cancelCurEditNode(setting);
                    }
                }).bind('keydown', function (event) {
                    if (event.keyCode == "13") {
                        view.editNodeBlur = true;
                        view.cancelCurEditNode(setting);
                    } else if (event.keyCode == "27") {
                        view.cancelCurEditNode(setting, null, true);
                    }
                }).bind('click', function (event) {
                    return false;
                }).bind('dblclick', function (event) {
                    return false;
                });

                $$(node, consts.id.A, setting).addClass(consts.node.CURSELECTED_EDIT);
                root.curEditInput = inputObj;
                root.noSelection = false;
                root.curEditNode = node;
            },
            moveNode: function (setting, targetNode, node, moveType, animateFlag, isSilent) {
                var root = data.getRoot(setting);
                if (targetNode == node) return;
                if (setting.data.keep.leaf && targetNode && !data.nodeIsParent(setting, targetNode) && moveType == consts.move.TYPE_INNER) return;
                var oldParentNode = (node.parentTId ? node.getParentNode() : root),
                    targetNodeIsRoot = (targetNode === null || targetNode == root);
                if (targetNodeIsRoot && targetNode === null) targetNode = root;
                if (targetNodeIsRoot) moveType = consts.move.TYPE_INNER;
                var targetParentNode = (targetNode.parentTId ? targetNode.getParentNode() : root);

                if (moveType != consts.move.TYPE_PREV && moveType != consts.move.TYPE_NEXT) {
                    moveType = consts.move.TYPE_INNER;
                }

                if (moveType == consts.move.TYPE_INNER) {
                    if (targetNodeIsRoot) {
                        //parentTId of root node is null
                        node.parentTId = null;
                    } else {
                        if (!data.nodeIsParent(setting, targetNode)) {
                            data.nodeIsParent(setting, targetNode, true);
                            targetNode.open = !!targetNode.open;
                            view.setNodeLineIcos(setting, targetNode);
                        }
                        node.parentTId = targetNode.tId;
                    }
                }

                //move node Dom
                var targetObj, target_ulObj;
                if (targetNodeIsRoot) {
                    targetObj = setting.treeObj;
                    target_ulObj = targetObj;
                } else {
                    if (!isSilent && moveType == consts.move.TYPE_INNER) {
                        view.expandCollapseNode(setting, targetNode, true, false);
                    } else if (!isSilent) {
                        view.expandCollapseNode(setting, targetNode.getParentNode(), true, false);
                    }
                    targetObj = $$(targetNode, setting);
                    target_ulObj = $$(targetNode, consts.id.UL, setting);
                    if (!!targetObj.get(0) && !target_ulObj.get(0)) {
                        var ulstr = [];
                        view.makeUlHtml(setting, targetNode, ulstr, '');
                        targetObj.append(ulstr.join(''));
                    }
                    target_ulObj = $$(targetNode, consts.id.UL, setting);
                }
                var nodeDom = $$(node, setting);
                if (!nodeDom.get(0)) {
                    nodeDom = view.appendNodes(setting, node.level, [node], null, -1, false, true).join('');
                } else if (!targetObj.get(0)) {
                    nodeDom.remove();
                }
                if (target_ulObj.get(0) && moveType == consts.move.TYPE_INNER) {
                    target_ulObj.append(nodeDom);
                } else if (targetObj.get(0) && moveType == consts.move.TYPE_PREV) {
                    targetObj.before(nodeDom);
                } else if (targetObj.get(0) && moveType == consts.move.TYPE_NEXT) {
                    targetObj.after(nodeDom);
                }

                //repair the data after move
                var i, l,
                    tmpSrcIndex = -1,
                    tmpTargetIndex = 0,
                    oldNeighbor = null,
                    newNeighbor = null,
                    oldLevel = node.level;
                var oldChildren = data.nodeChildren(setting, oldParentNode);
                var targetParentChildren = data.nodeChildren(setting, targetParentNode);
                var targetChildren = data.nodeChildren(setting, targetNode);
                if (node.isFirstNode) {
                    tmpSrcIndex = 0;
                    if (oldChildren.length > 1) {
                        oldNeighbor = oldChildren[1];
                        oldNeighbor.isFirstNode = true;
                    }
                } else if (node.isLastNode) {
                    tmpSrcIndex = oldChildren.length - 1;
                    oldNeighbor = oldChildren[tmpSrcIndex - 1];
                    oldNeighbor.isLastNode = true;
                } else {
                    for (i = 0, l = oldChildren.length; i < l; i++) {
                        if (oldChildren[i].tId == node.tId) {
                            tmpSrcIndex = i;
                            break;
                        }
                    }
                }
                if (tmpSrcIndex >= 0) {
                    oldChildren.splice(tmpSrcIndex, 1);
                }
                if (moveType != consts.move.TYPE_INNER) {
                    for (i = 0, l = targetParentChildren.length; i < l; i++) {
                        if (targetParentChildren[i].tId == targetNode.tId) tmpTargetIndex = i;
                    }
                }
                if (moveType == consts.move.TYPE_INNER) {
                    if (!targetChildren) {
                        targetChildren = data.nodeChildren(setting, targetNode, []);
                    }
                    if (targetChildren.length > 0) {
                        newNeighbor = targetChildren[targetChildren.length - 1];
                        newNeighbor.isLastNode = false;
                    }
                    targetChildren.splice(targetChildren.length, 0, node);
                    node.isLastNode = true;
                    node.isFirstNode = (targetChildren.length == 1);
                } else if (targetNode.isFirstNode && moveType == consts.move.TYPE_PREV) {
                    targetParentChildren.splice(tmpTargetIndex, 0, node);
                    newNeighbor = targetNode;
                    newNeighbor.isFirstNode = false;
                    node.parentTId = targetNode.parentTId;
                    node.isFirstNode = true;
                    node.isLastNode = false;

                } else if (targetNode.isLastNode && moveType == consts.move.TYPE_NEXT) {
                    targetParentChildren.splice(tmpTargetIndex + 1, 0, node);
                    newNeighbor = targetNode;
                    newNeighbor.isLastNode = false;
                    node.parentTId = targetNode.parentTId;
                    node.isFirstNode = false;
                    node.isLastNode = true;

                } else {
                    if (moveType == consts.move.TYPE_PREV) {
                        targetParentChildren.splice(tmpTargetIndex, 0, node);
                    } else {
                        targetParentChildren.splice(tmpTargetIndex + 1, 0, node);
                    }
                    node.parentTId = targetNode.parentTId;
                    node.isFirstNode = false;
                    node.isLastNode = false;
                }
                data.fixPIdKeyValue(setting, node);
                data.setSonNodeLevel(setting, node.getParentNode(), node);

                //repair node what been moved
                view.setNodeLineIcos(setting, node);
                view.repairNodeLevelClass(setting, node, oldLevel);

                //repair node's old parentNode dom
                if (!setting.data.keep.parent && oldChildren.length < 1) {
                    //old parentNode has no child nodes
                    data.nodeIsParent(setting, oldParentNode, false);
                    oldParentNode.open = false;
                    var tmp_ulObj = $$(oldParentNode, consts.id.UL, setting),
                        tmp_switchObj = $$(oldParentNode, consts.id.SWITCH, setting),
                        tmp_icoObj = $$(oldParentNode, consts.id.ICON, setting);
                    view.replaceSwitchClass(oldParentNode, tmp_switchObj, consts.folder.DOCU);
                    view.replaceIcoClass(oldParentNode, tmp_icoObj, consts.folder.DOCU);
                    tmp_ulObj.css("display", "none");

                } else if (oldNeighbor) {
                    //old neigbor node
                    view.setNodeLineIcos(setting, oldNeighbor);
                }

                //new neigbor node
                if (newNeighbor) {
                    view.setNodeLineIcos(setting, newNeighbor);
                }

                //repair checkbox / radio
                if (!!setting.check && setting.check.enable && view.repairChkClass) {
                    view.repairChkClass(setting, oldParentNode);
                    view.repairParentChkClassWithSelf(setting, oldParentNode);
                    if (oldParentNode != node.parent)
                        view.repairParentChkClassWithSelf(setting, node);
                }

                //expand parents after move
                if (!isSilent) {
                    view.expandCollapseParentNode(setting, node.getParentNode(), true, animateFlag);
                }
            },
            removeEditBtn: function (setting, node) {
                $$(node, consts.id.EDIT, setting).unbind().remove();
            },
            removeRemoveBtn: function (setting, node) {
                $$(node, consts.id.REMOVE, setting).unbind().remove();
            },
            removeTreeDom: function (setting, node) {
                node.isHover = false;
                view.removeEditBtn(setting, node);
                view.removeRemoveBtn(setting, node);
                tools.apply(setting.view.removeHoverDom, [setting.treeId, node]);
            },
            repairNodeLevelClass: function (setting, node, oldLevel) {
                if (oldLevel === node.level) return;
                var liObj = $$(node, setting),
                    aObj = $$(node, consts.id.A, setting),
                    ulObj = $$(node, consts.id.UL, setting),
                    oldClass = consts.className.LEVEL + oldLevel,
                    newClass = consts.className.LEVEL + node.level;
                liObj.removeClass(oldClass);
                liObj.addClass(newClass);
                aObj.removeClass(oldClass);
                aObj.addClass(newClass);
                ulObj.removeClass(oldClass);
                ulObj.addClass(newClass);
            },
            selectNodes: function (setting, nodes) {
                for (var i = 0, l = nodes.length; i < l; i++) {
                    view.selectNode(setting, nodes[i], i > 0);
                }
            }
        };

        _z = {
            tools: _tools,
            view: _view,
            event: _event,
            data: _data
        };
        $.extend(true, tree.tree.consts, _consts);
        $.extend(true, tree.tree._z, _z);

        var zt = tree.tree,
            tools = zt._z.tools,
            consts = zt.consts,
            view = zt._z.view,
            data = zt._z.data,
            event = zt._z.event,
            $$ = tools.$;

        data.exSetting(_setting);
        data.addInitBind(_bindEvent);
        data.addInitUnBind(_unbindEvent);
        data.addInitCache(_initCache);
        data.addInitNode(_initNode);
        data.addInitProxy(_eventProxy);
        data.addInitRoot(_initRoot);
        data.addZTreeTools(_zTreeTools);

        var _cancelPreSelectedNode = view.cancelPreSelectedNode;
        view.cancelPreSelectedNode = function (setting, node) {
            var list = data.getRoot(setting).curSelectedList;
            for (var i = 0, j = list.length; i < j; i++) {
                if (!node || node === list[i]) {
                    view.removeTreeDom(setting, list[i]);
                    if (node) break;
                }
            }
            if (_cancelPreSelectedNode) _cancelPreSelectedNode.apply(view, arguments);
        };

        var _createNodes = view.createNodes;
        view.createNodes = function (setting, level, nodes, parentNode, index) {
            if (_createNodes) {
                _createNodes.apply(view, arguments);
            }
            if (!nodes) return;
            if (view.repairParentChkClassWithSelf) {
                view.repairParentChkClassWithSelf(setting, parentNode);
            }
        };

        var _makeNodeUrl = view.makeNodeUrl;
        view.makeNodeUrl = function (setting, node) {
            return setting.edit.enable ? null : (_makeNodeUrl.apply(view, arguments));
        };

        var _removeNode = view.removeNode;
        view.removeNode = function (setting, node) {
            var root = data.getRoot(setting);
            if (root.curEditNode === node) root.curEditNode = null;
            if (_removeNode) {
                _removeNode.apply(view, arguments);
            }
        };

        var _selectNode = view.selectNode;
        view.selectNode = function (setting, node, addFlag) {
            var root = data.getRoot(setting);
            if (data.isSelectedNode(setting, node) && root.curEditNode == node && node.editNameFlag) {
                return false;
            }
            if (_selectNode) _selectNode.apply(view, arguments);
            view.addHoverDom(setting, node);
            return true;
        };

        var _uCanDo = tools.uCanDo;
        tools.uCanDo = function (setting, e) {
            var root = data.getRoot(setting);
            if (e && (tools.eqs(e.type, "mouseover") || tools.eqs(e.type, "mouseout") || tools.eqs(e.type, "mousedown") || tools.eqs(e.type, "mouseup"))) {
                return true;
            }
            if (root.curEditNode) {
                view.editNodeBlur = false;
                root.curEditInput.focus();
            }
            return (!root.curEditNode) && (_uCanDo ? _uCanDo.apply(view, arguments) : true);
        }

    })();
    return {
        init: tree.tree.init,
        tree: tree.tree,
        tools: tree.tools,
    }
})();

XAPP.menu = (function () {
    var menuItems = {};
    var treemenu;
    function onBodyMouseDown(event) {
        if (!(event.target.id == "treemenu" || $(event.target).parents("#treemenu").length > 0)) {
            treemenu.css({ display: "none" });
        }
    }

    function show(type, x, y) {

        $("#treemenu ul").show();

        treemenu.css({ "top": y + "px", "left": x + "px", display: "block" });
        treemenu.find('.dropdown-submenu > ul').css({ display: "none" });

        treemenu.find('.dropdown-submenu > a').on('mouseover', function () {
            treemenu.find('.dropdown-submenu > ul').css({ display: "none", });
            console.log(this)
            if (!$(this).parent().hasClass("disabled")) { $(this).next('ul').css({ display: "block" }); }

        });

        treemenu.find('a.no-dropdown').on('mouseenter', function () {
            treemenu.find('.dropdown-submenu > ul').css({ display: "none" });
        });


        $("body").on("click", onBodyMouseDown);
    }
    function hide() {
        if (treemenu) treemenu.css({ display: "none" });
        $("body").unbind("click", onBodyMouseDown);
    }

    function createMenuList(options) {
        var ul = $('<ul class="dropdown-menu"></ul>')
        for (var i = 0; i < options.length; i++) {
            var opt = options[i]
            if (!opt.display) { continue }
            var li = $('<li></li>');

            menuItems[opt.id] = opt;
            if (opt.disabled) { li.addClass("disabled"); }
            var linkContent = $('<a id=' + opt.id + '><i class="fa fa-' + opt.class + '" style ="padding-right: 10px;font-size: 10px"></i>' + opt.name + '</a>')
            var link = $(linkContent).appendTo(li);

            link.on('click', (e) => {
                e.preventDefault();
                /* if ($(this).parent().hasClass("disabled")) {return;} */
                if ($(e.target.parentElement).hasClass("disabled")) {
                    return;
                }
                triggerAction(e.target.id)
            }
            )


            li.appendTo(ul)
        }
        return ul
    }

    function createMenuItem(opt) {
        var item = $('<li></li>');
        if (opt === null) {
            item.addClass("divider")
        } else if (opt.options === undefined) {
            if (!opt.display) return null
            menuItems[opt.id] = opt;

            $('<a id="' + opt.id + '" class="no-dropdown"><i class="fa fa-' + opt.class + '" style ="padding-right: 10px;font-size: 10px"></i>' + opt.name + '</a>').on('click', (e) => {
                e.preventDefault();
                if ($(e.target.parentElement).hasClass("disabled")) { return; }
                triggerAction(e.target.id)
            }).appendTo(item)
            if (opt.disabled) { item.addClass("disabled"); }


        } else {
            if (opt.disabled) { item.addClass("disabled"); }
            $('<a><i class="fa fa-' + opt.class + '" style ="padding-right: 10px;font-size: 10px"></i>' + opt.name + '</a>').appendTo(item)
            item.addClass("dropdown-submenu")
            item.append(createMenuList(opt.options))

        }
        return item;
    }

    function createMenu(options) {
        /* treemenu.empty() */
        var topMenu = $("<ul/>", { class: 'dropdown-menu', style: 'display:none' });
        for (var i = 0; i < options.length; i++) {
            var opt = options[i]
            var li = createMenuItem(opt);
            if (li) {
                topMenu.append(li)
            }
        }
        return topMenu
    }

    function triggerAction(id, args) {
        var opt = menuItems[id];
        if (opt && opt.onselect) {
            var callback = opt.onselect;
            if (typeof opt.onselect === 'string') {
                callback = XAPP.actions.get(opt.onselect);
            }
            if (callback) {
                callback.call(opt, args);
            } else {
                console.log("No callback for", id, opt.onselect);
            }
        }
    }
    function load(Node) {

        levelselectedNode = Node.level;
        var menuOptions = []
        treemenu.empty()

        var menu_new = { id: "tree-new", name: "New", disabled: true, display: true, class: "plus", options: [] }
        //Init Menu
        var config = [
            { id: "tree-new-connection", name: "Connection", disabled: false, display: (levelselectedNode == 1), onselect: "core:tree-new-connection", type: "connection", class: "plug" },
            { id: "tree-new-tag-group", name: "Groupe", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-group", type: "groupe", class: "cube" },
            { id: "tree-new-tag-archive", name: "Tag", disabled: false, display: (levelselectedNode == 3), onselect: "core:tree-new-tag-archive", type: "tag", class: "tag" },
        ]

        var dashboard = [
            { id: "tree-new-ui-tab", name: "Tab", disabled: false, display: (levelselectedNode == 1), onselect: "core:tree-new-ui-tab", class: "cubes" },
            // { id: "tree-new-ui-group", name: "Group", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-ui-group", class: "cube" },
            { id: "tree-new-ui-gauge", name: "Gauge", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-ui-gauge", class: "tachometer-alt" },
            { id: "tree-new-tag-ui-piechart", name: "Pie Chart", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-ui-piechart", class: "pie-chart" },
            { id: "tree-new-tag-ui-barchart", name: "Bar Chart", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-ui-barchart", class: "bar-chart" },
            { id: "tree-new-tag-ui-template", name: "template", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-ui-template", class: "file-code" },

            { id: "tree-new-tag-ui-uispark", name: "Spark", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-ui-uispark", class: "line-chart" },
            /*             { id: "tree-new-tag-ui-uiprogressbar", name: "Progress Bar", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-ui-uiprogressbar", class: "progressbar" },
                       { id: "tree-new-tag-ui-uiprogressbox", name: "Progress Box", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-ui-uiprogressbox", class: "progressbox" },
                       { id: "tree-new-tag-ui-uiinline", name: "Inline", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-ui-uiinline", class: "inline" },
                       { id: "tree-new-tag-ui-uiinfobox", name: "Info Box", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-ui-uiinfobox", class: "bell" }, */
            { id: "tree-new-ui-statemachine", name: "State Machine", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-statemachine", class: "server" },
        ]

        var data = [
            { id: "tree-new-ui-db", name: "Data Base", disabled: false, display: (levelselectedNode == 1), onselect: "core:tree-new-db", class: "database" },
            { id: "tree-new-ui-coll", name: "Collection", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-coll", class: "cube" },
        ]

        var mobile = [
            { id: "core:tree-new-mmobile", name: "Mobile", disabled: false, display: (levelselectedNode == 1), onselect: "core:tree-new-mmobile", class: "mobile" },
            { id: "core:tree-new-mwidget", name: "Widgets", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-mwidget", class: "progressbar" },
            { id: "core:tree-new-mpiechart", name: "Pei Chart", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-mpiechart", class: "pie-chart" },
            { id: "core:tree-new-mbarchart", name: "Bar Chart", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-mbarchart", class: "bar-chart" },
        ]

        var report = [
            { id: "core:tree-new-rpreport", name: "Report", disabled: false, display: (levelselectedNode == 1), onselect: "core:tree-new-rpreport", class: "mobile" },
            { id: "core:tree-new-rpwidget", name: "Widget", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-rpwidget", class: "progressbar" },
            { id: "core:tree-new-rptemplate", name: "Template", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-rptemplate", class: "progressbar" },
            { id: "core:tree-new-rpchart", name: "Chart", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-rpchart", class: "progressbar" },
        ]


        var datapoint = [
            { id: "tree-new-ui-statemachine", name: "State Machine", disabled: false, display: (levelselectedNode == 1), onselect: "core:tree-new-statemachine", class: "datapoint" },
            { id: "tree-new-ui-batch", name: "Batch List", disabled: false, display: (levelselectedNode == 1), onselect: "core:tree-new-batch", class: "datapoint" },
            { id: "tree-new-tag-status", name: "Status", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-status", type: "alarm", class: "bolt" },
            { id: "tree-new-tag-phase", name: "Phase", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-phase", type: "alarm", class: "bolt" },
            { id: "tree-new-tag-alarm", name: "Alarms", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-alarm", type: "alarm", class: "bolt" },
            { id: "tree-new-tag-trend", name: "Trend", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-trend", type: "alarm", class: "bar-chart" },

            { id: "tree-new-ui-datapoint", name: "Data Point", disabled: false, display: (levelselectedNode == 1), onselect: "core:tree-new-datapoint", class: "datapoint" },
            { id: "tree-new-ui-calc", name: "Calculator", disabled: false, display: (levelselectedNode == 2), onselect: "core:tree-new-calculator", class: "calculator" },
        ]

        var rootNode = XAPP.treelist.actions.getRoot(Node)

        var submenu = [];
        switch (rootNode.name) {
            case 'Configuration': submenu = config; break;
            case 'Data Base': submenu = data; break;
            case 'Dashboard': submenu = dashboard; break;
            case 'Mobile': submenu = mobile; break;
            case 'Data Point': submenu = datapoint; break;
            case 'Report': submenu = report; break;
            default: submenu = [];

        }

        if (submenu.length === 0 || submenu === undefined) {
            menu_new.disabled = true
        } else {
            menu_new.options.push(...submenu)
        }

        submenu.forEach((m) => {
            if (m.display) menu_new.disabled = false;
        })


        menuOptions.push(menu_new)


        menuOptions.push(null);
        menuOptions.push({ id: "tree-node-refresh", name: "Refresh", disabled: false, display: true, onselect: "core:tree-node-refresh", class: "exchange" });
        menuOptions.push(null);
        menuOptions.push({ id: "tree-node-cut", name: "Cut", disabled: false, display: true, onselect: "core:tree-node-cut", class: "cut" });
        menuOptions.push({ id: "tree-node-copy", name: "Copy", disabled: false, display: true, onselect: "core:tree-node-copy", class: "copy" });
        menuOptions.push({ id: "tree-node-paste", name: "Paste", disabled: false, display: true, onselect: "core:tree-node-paste", class: "paste" });
        menuOptions.push(null);
        menuOptions.push({ id: "tree-node-delete", name: "Delete", disabled: false, display: true, onselect: "core:tree-node-delete", class: "eraser" });
        menuOptions.push(null);
        menuOptions.push({ id: "tree-node-export", name: "Export", disabled: false, display: true, onselect: "core:tree-node-export", class: "file-export" });
        menuOptions.push({ id: "core:tree-import", name: "Import", disabled: false, display: true, onselect: "core:tree-node-import", class: "file-import" });

        createMenu(menuOptions).appendTo(treemenu)
    }
    function init() {
        treemenu = $(`<div id="treemenu" class="treemenu"></div>`).appendTo(`#red-ui-editor`);
    }
    return {
        load: load,
        init: init,
        show: show,
        hide: hide
    }
})();

XAPP.navbar = (function () {
    var menuItems = []
    function triggerAction(id, args) {
        var opt = menuItems[id];
        if (opt && opt.onselect) {
            var callback = opt.onselect;
            if (typeof opt.onselect === 'string') {
                callback = XAPP.actions.get(opt.onselect);
            }
            if (callback) {
                callback.call(opt, args);
            } else {
                console.log("No callback for", id, opt.onselect);
            }
        }
    }

    function createMenuItem(opt) {
        var item;

        function setInitialState() {

        }

        if (opt === null) {
            item = $('<li class="divider"></li>');
        } else {
            item = $('<li></li>');

            if (opt.group) {
                item.addClass("red-ui-menu-group-" + opt.group);

            }
            var linkContent = '<a ' + (opt.id ? 'id="' + opt.id + '" ' : '') + 'tabindex="-1" href="#">';
            if (opt.toggle) {
                linkContent += '<i class="fa fa-square pull-' + opt.position + '"></i>';
                linkContent += '<i class="fa fa-check-square pull-' + opt.position + '"></i>';

            }
            if (opt.icon !== undefined) {
                if (/\.(png|svg)/.test(opt.icon)) {
                    linkContent += '<img src="' + opt.icon + '"/> ';
                } else {
                    linkContent += '<i class="' + (opt.icon ? opt.icon : '" style="display: inline-block;"') + '"></i> ';
                }
            }

            if (opt.sublabel) {
                linkContent += '<span class="red-ui-menu-label-container"><span class="red-ui-menu-label">' + opt.label + '</span>' +
                    '<span class="red-ui-menu-sublabel">' + opt.sublabel + '</span></span>'
            } else {
                linkContent += '<span class="red-ui-menu-label">' + opt.label + '</span>'
            }

            linkContent += '</a>';

            var link = $(linkContent).appendTo(item);

            menuItems[opt.id] = opt;

            if (opt.onselect) {
                link.on("click", function (e) {
                    e.preventDefault();
                    console.log("click")
                    if ($(this).parent().hasClass("disabled")) {
                        return;
                    }
                    if (opt.toggle) {
                        if (opt.toggle === true) {
                            setSelected(opt.id, !isSelected(opt.id));
                        } else {
                            setSelected(opt.id, true);
                        }
                    } else {
                        triggerAction(opt.id);
                    }
                });
                if (opt.toggle) {
                    setInitialState();
                }
            } else if (opt.href) {
                link.attr("target", "_blank").attr("href", opt.href);
            } else if (!opt.options) {
                item.addClass("disabled");
                link.on("click", function (event) {
                    event.preventDefault();
                });
            }
            if (opt.options) {
                item.addClass("dropdown-submenu");
                var submenu = $('<ul id="' + opt.id + '-submenu" class="dropdown-menu"></ul>').appendTo(item);

                for (var i = 0; i < opt.options.length; i++) {
                    var li = createMenuItem(opt.options[i]);
                    if (li) {
                        li.appendTo(submenu);
                    }
                }
            }
            if (opt.disabled) {
                item.addClass("disabled");
            }
        }


        return item;

    }
    function createMenu(options) {
        var topMenu = $("<ul/>", { class: "dropdown-menu" });

        if (options.id) {
            topMenu.attr({ id: options.id + "-submenu" });
            var menuParent = $("#" + options.id);
            if (menuParent.length === 1) {
                topMenu.insertAfter(menuParent);
                menuParent.on("click", function (evt) {
                    evt.stopPropagation();
                    evt.preventDefault();

                    if (topMenu.is(":visible")) {
                        console.log("Visible")
                        $(document).off("click.red-ui-menu");
                        topMenu.hide();
                    } else {
                        console.log("Not visible")
                        $(document).on("click.red-ui-menu", function (evt) {
                            $(document).off("click.red-ui-menu");
                            activeMenu = null;
                            topMenu.hide();
                        });
                        $(".red-ui-menu").hide();
                        topMenu.show();
                    }
                })
            }
        }

        var lastAddedSeparator = false;
        for (var i = 0; i < options.options.length; i++) {
            var opt = options.options[i];
            if (opt !== null || !lastAddedSeparator) {
                var li = createMenuItem(opt);
                if (li) {
                    li.appendTo(topMenu);
                    lastAddedSeparator = (opt === null);
                }
            }
        }

        return topMenu;
    }


    function isSelected(id) {
        return $("#" + id).hasClass("active");
    }

    function setSelected(id, state) {
        var alreadySet = false;
        if (isSelected(id) == state) {
            alreadySet = true;
        }
        var opt = menuItems[id];
        if (state) {
            $("#" + id).addClass("active");
        } else {
            $("#" + id).removeClass("active");
        }
        if (opt) {
            if (opt.toggle && typeof opt.toggle === "string") {
                if (state) {
                    for (var m in menuItems) {
                        if (menuItems.hasOwnProperty(m)) {
                            var mi = menuItems[m];
                            if (mi.id != opt.id && opt.toggle == mi.toggle) {
                                setSelected(mi.id, false);
                            }
                        }
                    }
                }
            }
            if (!alreadySet && opt.onselect) {
                triggerAction(opt.id, state);
            }
            if (!opt.local && !alreadySet) {
                RED.settings.set(opt.setting || ("menu-" + opt.id), state);
            }
        }
    }

    function toggleSelected(id) {
        setSelected(id, !isSelected(id));
    }

    function setDisabled(id, state) {
        if (state) {
            $("#" + id).parent().addClass("disabled");
        } else {
            $("#" + id).parent().removeClass("disabled");
        }
    }

    function addItem(id, opt) {
        var item = createMenuItem(opt);
        if (opt !== null && opt.group) {
            var groupItems = $("#" + id + "-submenu").children(".red-ui-menu-group-" + opt.group);
            if (groupItems.length === 0) {
                item.appendTo("#" + id + "-submenu");
            } else {
                for (var i = 0; i < groupItems.length; i++) {
                    var groupItem = groupItems[i];
                    var label = $(groupItem).find(".red-ui-menu-label").html();
                    if (opt.label < label) {
                        $(groupItem).before(item);
                        break;
                    }
                }
                if (i === groupItems.length) {
                    item.appendTo("#" + id + "-submenu");
                }
            }
        } else {
            item.appendTo("#" + id + "-submenu");
        }
    }
    function removeItem(id) {
        $("#" + id).parent().remove();
    }

    function setAction(id, action) {
        var opt = menuItems[id];
        if (opt) {
            opt.onselect = action;
        }
    }

    function buildLeftMenu() {
        var menu = [];
        var menuOptions = [];
        var container = $("#menu-left")



        menu.push({ id: "menu-item-system", label: "System" })
        menu.push({ id: "menu-item-users", label: "Users" })
        menu.push({ id: "menu-item-extensions", label: "Extensions" })
        menu.push({ id: "menu-item-options", label: "Options" })
        menu.push({ id: "menu-item-help", label: "Help" })

        for (var i = 0; i < menu.length; i++) {
            var menuItem = menu[i];
            var item = $('<li class="dropdown"><a ' + (menuItem.id ? 'id="' + menuItem.id + '" ' : '') + 'href="#">' + menuItem.label + '<span class="caret"></span></a></li>');

            $(item).appendTo(container).on('mouseenter', function () {
                container.find('> li > ul').css('display', 'none');

            });

        }



        XAPP.actions.add("core:toggle-control-panel", function () { console.log("core:toggle-control-panel") });
        XAPP.actions.add("core:toggle-global-configuration", function () { console.log("core:toggle-global-configuration") });
        XAPP.actions.add("core:toggle-global-check-in", function () { console.log("core:toggle-global-check-in") });
        XAPP.actions.add("core:toggle-clear-cache", function () { console.log("core:toggle-clear-cache") });
        XAPP.actions.add("core:toggle-clear-epired-cache", function () { console.log("core:toggle-clear-epired-cache") });
        XAPP.actions.add("core:toggle-add-new-user", function () { console.log("core:toggle-add-new-user") });
        XAPP.actions.add("core:toggle-add-new-group", function () { console.log("core:toggle-add-new-group") });

        menuOptions = []
        menuOptions.push({ id: "menu-item-control-panel", label: "Control Panel", onselect: "core:toggle-control-panel", display: null, selected: true });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-global-configuration", label: "Global Configuration", onselect: "core:toggle-global-configuration", display: null, selected: true });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-global-check-in", label: "Global Check-in", onselect: "core:toggle-global-check-in", display: null, selected: true });
        menuOptions.push({ id: "menu-item-clear-cache", label: "Clear Cache", onselect: "core:toggle-clear-cache", display: null, selected: true });
        menuOptions.push({ id: "menu-item-clear-expired-cache", label: "Clear Expired Cache", onselect: "core:toggle-clear-epired-cache", display: null, selected: true });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-system-information", label: "System Information", onselect: "core:toggle-system-information", display: null, selected: true });
        createMenu({ id: "menu-item-system", options: menuOptions });



        menuOptions = []
        menuOptions.push({
            id: "menu-item-manage", label: "Manage", onselect: "core:toggle-manage", display: null, selected: true, options: [
                { id: "menu-item-add-new-user", label: "Add New User", onselect: "core:toggle-add-new-user", display: null, selected: true },
                { id: "menu-item-add-new-group", label: "Add New Group", onselect: "core:toggle-add-new-group", display: null, selected: true },
            ]
        });
        menuOptions.push({ id: "menu-item-access-levels", label: "Access Levels", onselect: "core:toggle-access-levels", display: null, selected: true });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-fields", label: "Fields", onselect: "core:toggle-fields", display: null, selected: true });
        menuOptions.push({ id: "menu-item-field-groups", label: "Field Groups", onselect: "core:toggle-field-group", display: null, selected: true });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-user-notes", label: "User Notes", onselect: "core:toggle-user-notes", display: null, selected: true });
        menuOptions.push({ id: "menu-item-user-note-categories", label: "User Note Categories", onselect: "core:toggle-user-note-categories", display: null, selected: true });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-privacy", label: "Privacy", onselect: "core:toggle-privacy", display: null, selected: true });
        menuOptions.push({ id: "menu-item-user-actions-log", label: "User Actions Log", onselect: "core:toggle-user-actions-log", display: null, selected: true });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-mass-mail-users", label: "Mass Mail Users", onselect: "core:toggle-mass-mail-users", display: null, selected: true });
        createMenu({ id: "menu-item-users", options: menuOptions });



        menuOptions = []
        menuOptions.push({
            id: "menu-item-manage", label: "Manage", onselect: "core:toggle-manage", display: null, selected: true, options: [
                { id: "menu-item-add-new-user", label: "Install", onselect: "core:toggle-add-new-user", display: null, selected: true },
                { id: "menu-item-add-new-group", label: "Update", onselect: "core:toggle-add-new-group", display: null, selected: true },
                { id: "menu-item-add-new-group", label: "Manage", onselect: "core:toggle-add-new-group", display: null, selected: true },
                { id: "menu-item-add-new-group", label: "Discover", onselect: "core:toggle-add-new-group", display: null, selected: true },
                { id: "menu-item-add-new-group", label: "Database", onselect: "core:toggle-add-new-group", display: null, selected: true },
                { id: "menu-item-add-new-group", label: "Warning", onselect: "core:toggle-add-new-group", display: null, selected: true },
                { id: "menu-item-add-new-group", label: "Install languages", onselect: "core:toggle-add-new-group", display: null, selected: true },
                { id: "menu-item-add-new-group", label: "Updates Sites", onselect: "core:toggle-add-new-group", display: null, selected: true },
            ]
        });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-access-levels", label: "Modules", onselect: "core:toggle-access-levels", display: null, selected: true });
        menuOptions.push({ id: "menu-item-access-levels", label: "Plugins", onselect: "core:toggle-access-levels", display: null, selected: true });
        menuOptions.push({
            id: "menu-item-manage", label: "Templates", onselect: "core:toggle-manage", display: null, selected: true, options: [
                { id: "menu-item-add-new-user", label: "Styles", onselect: "core:toggle-add-new-user", display: null, selected: true },
                { id: "menu-item-add-new-group", label: "Templates", onselect: "core:toggle-add-new-group", display: null, selected: true },
            ]
        });
        menuOptions.push({
            id: "menu-item-manage", label: "Language(s)", onselect: "core:toggle-manage", display: null, selected: true, options: [
                { id: "menu-item-add-new-user", label: "Installed", onselect: "core:toggle-add-new-user", display: null, selected: true },
                { id: "menu-item-add-new-group", label: "Overrides", onselect: "core:toggle-add-new-group", display: null, selected: true },
                { id: "menu-item-add-new-group", label: "Content Languages", onselect: "core:toggle-add-new-group", display: null, selected: true },
            ]
        });
        createMenu({ id: "menu-item-extensions", options: menuOptions });





        menuOptions = []
        menuOptions.push({
            id: "menu-item-projects-menu", label: "Project", options: [
                { id: "menu-item-projects-new", label: "New", disabled: false, onselect: "core:new-project" },
                { id: "menu-item-projects-open", label: "Open", disabled: false, onselect: "core:open-project" },
                { id: "menu-item-projects-settings", label: "Settings", disabled: false, onselect: "core:show-project-settings" }
            ]
        });
        menuOptions.push(null);
        menuOptions.push({
            id: "menu-item-view-menu", label: "View", options: [
                { id: "menu-item-palette", label: "Palette Show", toggle: true, position: "right", onselect: "core:toggle-palette", selected: true },
                { id: "menu-item-sidebar", label: "Sidebar Show", toggle: true, position: "right", onselect: "core:toggle-sidebar", selected: true },
                { id: "menu-item-event-log", label: "EventLog title", onselect: "core:show-event-log" },
                { id: "menu-item-action-list", label: "Keyboard Action List", onselect: "core:show-action-list" },
            ]
        });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-import", label: "Import", onselect: "core:show-import-dialog" });
        menuOptions.push({ id: "menu-item-export", label: "Export", onselect: "core:show-export-dialog" });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-search", label: "Search", onselect: "core:search" });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-config-nodes", label: "Display Config", onselect: "core:show-config-tab" });
        menuOptions.push({
            id: "menu-item-workspace", label: "Flows", options: [
                { id: "menu-item-workspace-add", label: "Add", onselect: "core:add-flow" },
                { id: "menu-item-workspace-edit", label: "Rename", onselect: "core:edit-flow" },
                { id: "menu-item-workspace-delete", label: "Delete", onselect: "core:remove-flow" }
            ]
        });
        menuOptions.push({
            id: "menu-item-subflow", label: "Subflows", options: [
                { id: "menu-item-subflow-create", label: "Create Sub Flow", onselect: "core:create-subflow" },
                { id: "menu-item-subflow-convert", label: "Selection To Subflow", disabled: true, onselect: "core:convert-to-subflow" },
            ]
        });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-edit-palette", label: "Edit Palette", onselect: "core:manage-palette" });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-user-settings", label: "Settings", onselect: "core:show-user-settings" });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-keyboard-shortcuts", label: "Keyboard Shortcuts", onselect: "core:show-help" });
        menuOptions.push({ id: "menu-item-node-red-version", label: "Version", onselect: "core:show-about" });
        createMenu({ id: "menu-item-options", options: menuOptions });




        menuOptions = []
        menuOptions.push({ id: "menu-item-access-levels", label: "Community Portal", onselect: "core:toggle-access-levels", display: null, selected: true });
        menuOptions.push({ id: "menu-item-access-levels", label: "Security Centre", onselect: "core:toggle-access-levels", display: null, selected: true });
        menuOptions.push({ id: "menu-item-access-levels", label: "Official Support Forume", onselect: "core:toggle-access-levels", display: null, selected: true });
        menuOptions.push({ id: "menu-item-access-levels", label: "Developer Resources", onselect: "core:toggle-access-levels", display: null, selected: true });
        createMenu({ id: "menu-item-help", options: menuOptions });





    }

    function buildRightMenu() {

        var container = $("#menu-right")
        var menu = []
        menu.push({ id: "menu-item-user", label: "System", icon: "fa fa-user", caret: true })
        menu.push({ id: "menu-item-more-options", label: "Users", icon: "fa fa-bars", caret: false })


        for (var i = 0; i < menu.length; i++) {
            var menuItem = menu[i]
            var itemContent = '<li class="dropdown"><a ' + (menuItem.id ? 'id="' + menuItem.id + '" ' : '') + 'href="#"><i class="' + menuItem.icon + '">';
            if (menuItem.caret) {
                itemContent += '<span class="caret"></span>';
            }

            itemContent += '</a></li>'

            $(itemContent).appendTo(container).on('mouseenter', function () {
                container.find('> li > ul').css('display', 'none');

            });

        }
        menuOptions = []
        menuOptions.push({ id: "menu-item-access-levels", label: "Super user", onselect: "core:toggle-access-levels", display: null, selected: true });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-access-levels", label: "Edit Account", onselect: "core:toggle-access-levels", display: null, selected: true });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-access-levels", label: "Logout", onselect: "core:user-log-out", display: null, selected: true });
        createMenu({ id: "menu-item-user", options: menuOptions });

        XAPP.actions.add("core:user-log-out", function () { RED.user.logout(); });
        menuOptions = []
        menuOptions.push({
            id: "menu-item-projects-menu", label: "Project", options: [
                { id: "menu-item-projects-new", label: "New", disabled: false, onselect: "core:new-project" },
                { id: "menu-item-projects-open", label: "Open", disabled: false, onselect: "core:open-project" },
                { id: "menu-item-projects-settings", label: "Settings", disabled: false, onselect: "core:show-project-settings" }
            ]
        });
        menuOptions.push(null);
        menuOptions.push({
            id: "menu-item-view-menu", label: "View", options: [
                { id: "menu-item-palette", label: "Palette Show", toggle: true, position: "left", onselect: "core:toggle-palette", selected: true },
                { id: "menu-item-sidebar", label: "Sidebar Show", toggle: true, position: "left", onselect: "core:toggle-sidebar", selected: true },
                { id: "menu-item-event-log", label: "EventLog title", onselect: "core:show-event-log" },
                { id: "menu-item-action-list", label: "Keyboard Action List", onselect: "core:show-action-list" },
            ]
        });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-import", label: "Import", onselect: "core:show-import-dialog" });
        menuOptions.push({ id: "menu-item-export", label: "Export", onselect: "core:show-export-dialog" });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-search", label: "Search", onselect: "core:search" });
        menuOptions.push(null);
        menuOptions.push({ id: "menu-item-config-nodes", label: "Display Config", onselect: "core:show-config-tab" });
        menuOptions.push({
            id: "menu-item-workspace", label: "Flows", options: [
                { id: "menu-item-workspace-add", label: "Add", onselect: "core:add-flow" },
                { id: "menu-item-workspace-edit", label: "Rename", onselect: "core:edit-flow" },
                { id: "menu-item-workspace-delete", label: "Delete", onselect: "core:remove-flow" }
            ]
        });
        createMenu({ id: "menu-item-more-options", options: menuOptions });



    }

    function init(options) {
        var navbar_container = $(`
                                <!-- Top Navigation -->
                                <nav class="j-navbar j-navbar-inverse j-navbar-fixed-top">
                                    <div class="j-navbar-inner">
                                        <div class="j-container-fluid">
                                            <a href="#" class="btn btn-j-navbar collapsed" data-toggle="collapse" data-target=".j-nav-collapse">
                                                <span class="element-invisible">Toggle Navigation</span>
                                                <span class="j-icon-bar"></span>
                                                <span class="j-icon-bar"></span>
                                                <span class="j-icon-bar"></span>
                                            </a>
                                            <a class="element-invisible" href="#skiptarget">Skip to Main Content</a>

                                            <a class="admin-logo" href="#">
                                            <img class="fit-picture" width="64" height="64"src="xapp/images/logo_xapp.png" alt="Grapefruit slice atop a pile of other slices">
                                                <div class="element-invisible">Control Panel</div>
                                            </a>

                                            <a class="brand hidden-desktop hidden-tablet" href="#" title="Preview Siemens S7" target="_blank">XAPP</a>

                                            <div class="j-nav-collapse j-collapse">
                                                <ul id="menu-left" class="nav menu-left"></ul>
                                                <ul id="menu-right" class="nav menu-right pull-right"></ul>
                                                <ul id="nav-empty" class="dropdown-menu nav-empty hidden-phone" style="display: none;"></ul>
                                                <span class="icon-out-2 small"></span>
                                            </div>
                                        </div>
                                    </div>
                                </nav>
                                <!-- Top Navigation -->
                               `).appendTo(options.target)
        buildLeftMenu();
        buildRightMenu();
    }
    return {
        build: buildLeftMenu,
        init: init,
        setSelected: setSelected,
        isSelected: isSelected,
        toggleSelected: toggleSelected,
        setDisabled: setDisabled,
        addItem: addItem,
        removeItem: removeItem,
        setAction: setAction
    }

})();

XAPP.toolbar = (function () {
    var menuItems = {};

    function triggerAction(id, args) {
        var opt = menuItems[id];
        var callback = opt.onselect;
        if (typeof opt.onselect === 'string') {
            callback = XAPP.actions.get(opt.onselect);
        }
        if (callback) {
            callback.call(opt, args);
        } else {
            console.log("No callback for", id, opt.onselect);
        }
    }

    function createToolbarItem(opt) {
        menuItems[opt.id] = opt;
        var item = $('<div id ="' + opt.id + '" class="j-btn-wrapper"></div>');

        var btnContent = '<button class="' + opt.class + '">';
        btnContent += '<span class="' + opt.icon + '"aria-hidden="true"></span>' + opt.label;
        btnContent += '</button>';

        var btn = $(btnContent).appendTo(item);

        if (opt.onselect) {
            btn.on("click", function (e) {
                e.preventDefault();
                if ($(this).parent().hasClass("disabled")) {
                    return;
                }

                triggerAction(opt.id);
            })
        }
        return item;
    }
    function createToolbar(container, options) {
        for (var i = 0; i < options.length; i++) {
            var opt = options[i]
            var toolbarItem = createToolbarItem(opt);
            if (toolbarItem) {
                container.append(toolbarItem)
            }
        }
    }
    function buildtoolbar() {
        var toolbarOptions = [];
        var container = $("#j-toolbar")

        toolbarOptions.push({ id: "toolbar-new", label: "New", display: true, disabled: false, icon: 'j-icon-new j-icon-white', class: "btn btn-small button-new btn-success", onselect: "core:toggle-toolbar-new" });
        toolbarOptions.push({ id: "toolbar-edit", label: "Edit", display: true, disabled: false, icon: 'j-icon-edit', class: "btn btn-small", onselect: "core:toggle-toolbar-edit" });
        //toolbarOptions.push({ id: "toolbar-trash", label: "Trash", display: true, disabled: false, icon: 'j-icon-trash', class: "btn btn-small", onselect: "core:toggle-toolbar-trash" });
        toolbarOptions.push({ id: "toolbar-checkin", label: "Check-in", display: true, disabled: false, icon: 'j-icon-checkin', class: "btn btn-small", onselect: "core:toggle-toolbar-checkin" });
        toolbarOptions.push({ id: "toolbar-default", label: "Home", display: true, disabled: false, icon: 'j-icon-default', class: "btn btn-small", onselect: "core:toggle-toolbar-default" });
        toolbarOptions.push({ id: "toolbar-refresh", label: "Rebuild", display: true, disabled: false, icon: 'j-icon-refresh', class: "btn btn-small", onselect: "core:toggle-toolbar-refresh" });
       // toolbarOptions.push({ id: "toolbar-publish", label: "Publish", display: true, disabled: false, icon: 'j-icon-publish', class: "btn btn-small", onselect: "core:toggle-toolbar-publish" });
        //toolbarOptions.push({ id: "toolbar-unpublish", label: "Unpublish", display: true, disabled: false, icon: 'j-icon-unpublish', class: "btn btn-small", onselect: "core:toggle-toolbar-unpublish" });
        toolbarOptions.push({ id: "toolbar-options", label: "Options", display: true, disabled: false, icon: 'j-icon-options', class: "btn btn-small", onselect: "core:toggle-toolbar-options" });
        toolbarOptions.push({ id: "toolbar-help", label: "Help", display: true, disabled: false, icon: 'j-icon-question-sign', class: "btn btn-small", onselect: "core:toggle-toolbar-help" });

        //if ($(this).parent().hasClass("disabled")) {
        function diffText(string1, string2, ignoreWhitespace) {
            var lines1 = string1.split(/\r?\n/);
            var lines2 = string2.split(/\r?\n/);
            var i = lines1.length;
            var j = lines2.length;
            var k;
            var m;
            var diffSummary = { a: [], b: [] };
            var diffMap = [];
            for (k = 0; k < i + 1; k++) {
                diffMap[k] = [];
                for (m = 0; m < j + 1; m++) {
                    diffMap[k][m] = 0;
                }
            }
            var c = 0;
            for (k = i - 1; k >= 0; k--) {
                for (m = j - 1; m >= 0; m--) {
                    c++;
                    if (compareLines(lines1[k], lines2[m], ignoreWhitespace) !== 1) {
                        diffMap[k][m] = diffMap[k + 1][m + 1] + 1;
                    } else {
                        diffMap[k][m] = Math.max(diffMap[(k + 1)][m], diffMap[k][(m + 1)]);
                    }
                }
            }
            //console.log(c);
            k = 0;
            m = 0;

            while ((k < i) && (m < j)) {
                var n = compareLines(lines1[k], lines2[m], ignoreWhitespace);
                if (n !== 1) {
                    var d = 0;
                    if (n === 0) {
                        d = 0;
                    } else if (n == 2) {
                        d = 3;
                    }
                    diffSummary.a.push({ i: k + 1, j: m + 1, line: lines1[k], type: d });
                    diffSummary.b.push({ i: m + 1, j: k + 1, line: lines2[m], type: d });
                    k++;
                    m++;
                } else if (diffMap[(k + 1)][m] >= diffMap[k][(m + 1)]) {
                    diffSummary.a.push({ i: k + 1, line: lines1[k], type: 1 });
                    k++;
                } else {
                    diffSummary.b.push({ i: m + 1, line: lines2[m], type: 4 });
                    m++;
                }
            }
            while ((k < i) || (m < j)) {
                if (k == i) {
                    diffSummary.b.push({ i: m + 1, line: lines2[m], type: 4 });
                    m++;
                } else if (m == j) {
                    diffSummary.a.push({ i: k + 1, line: lines1[k], type: 1 });
                    k++;
                }
            }
            return diffSummary;
        }

        function compareLines(string1, string2, ignoreWhitespace) {
            if (ignoreWhitespace) {
                if (string1 === string2) {
                    return 0;
                }
                return string1.trim() === string2.trime() ? 2 : 1;
            }
            return string1 === string2 ? 0 : 1;
        }
        function createDiffLine(diffLine) {
            var diffRow = $('<tr>');
            var Adiff = diffLine.a;
            var Bdiff = diffLine.b;
            //console.log(diffLine);
            var cellNo = $('<td class="lineno">').text(Adiff.type === 2 ? "" : Adiff.i).appendTo(diffRow);
            var cellLine = $('<td class="linetext">').text(Adiff.line).appendTo(diffRow);
            if (Adiff.type === 2) {
                cellNo.addClass('blank');
                cellLine.addClass('blank');
            } else if (Adiff.type === 4) {
                cellNo.addClass('added');
                cellLine.addClass('added');
            } else if (Adiff.type === 1) {
                cellNo.addClass('removed');
                cellLine.addClass('removed');
            }
            cellNo = $('<td class="lineno">').text(Bdiff.type === 2 ? "" : Bdiff.i).appendTo(diffRow);
            cellLine = $('<td class="linetext">').text(Bdiff.line).appendTo(diffRow);
            if (Bdiff.type === 2) {
                cellNo.addClass('blank');
                cellLine.addClass('blank');
            } else if (Bdiff.type === 4) {
                cellNo.addClass('added');
                cellLine.addClass('added');
            } else if (Bdiff.type === 1) {
                cellNo.addClass('removed');
                cellLine.addClass('removed');
            }
            return diffRow;
        }

        function createExpandLine(start, end, diffLines) {
            diffRow = $('<tr class="red-ui-diff-text-header red-ui-diff-text-expand">');
            var content = $('<td colspan="4"> <i class="fa fa-arrows-v"></i> </td>').appendTo(diffRow);
            var label = $('<span></span>').appendTo(content);
            if (end < diffLines.length - 1) {
                label.text("@@ -" + (diffLines[end - 1].a.i + 1) + " +" + (diffLines[end - 1].b.i + 1));
            }
            diffRow.on("click", function (evt) {
                // console.log(start,end,diffLines.length);
                if (end - start > 20) {
                    var startPos = $(this).offset();
                    // console.log(startPos);
                    if (start > 0) {
                        for (var i = start; i < start + 10; i++) {
                            createDiffLine(diffLines[i]).addClass("unchanged").insertBefore($(this));
                        }
                        start += 10;
                    }
                    if (end < diffLines.length - 1) {
                        for (var i = end - 1; i > end - 11; i--) {
                            createDiffLine(diffLines[i]).addClass("unchanged").insertAfter($(this));
                        }
                        end -= 10;
                    }
                    if (end < diffLines.length - 1) {
                        label.text("@@ -" + (diffLines[end - 1].a.i + 1) + " +" + (diffLines[end - 1].b.i + 1));
                    }
                    var endPos = $(this).offset();
                    var delta = endPos.top - startPos.top;
                    $(".red-ui-diff-text").scrollTop($(".red-ui-diff-text").scrollTop() + delta);
                } else {
                    for (var i = start; i < end; i++) {
                        createDiffLine(diffLines[i]).addClass("unchanged").insertBefore($(this));
                    }
                    $(this).remove();
                }
            });
            return diffRow;
        }
        XAPP.actions.add("core:toggle-toolbar-new", function () {
            //Maher

            var localFlow = RED.nodes.createCompleteNodeSet();
            var originalFlow = RED.nodes.originalFlow();
            var textA = JSON.stringify(localFlow, null, 4);
            var textB = JSON.stringify(originalFlow, null, 4);

            var textA = "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22";
            var textB = "1\nTWO\nTHREE\nEXTRA\n4\n5\n6\n7\n8\n9\n10\n11\n12\nTHIRTEEN\n14\n15\n16\n17\n18\n19\n20\n21\n22";
            var trayOptions = {
                title: RED._("diff.compareChanges"),
                width: Infinity,
                overlay: true,
                buttons: [
                    {
                        text: RED._("common.label.close"),
                        click: function () {
                            RED.tray.close();
                        }
                    }
                ],
                resize: function (dimensions) {
                    // trayWidth = dimensions.width;
                },
                open: function (tray) {
                    var trayBody = tray.find('.red-ui-tray-body');
                    var diffPanel = $('<div class="red-ui-diff-text"></div>').appendTo(trayBody);

                    var codeTable = $("<table>", { class: "red-ui-diff-text-content" }).appendTo(diffPanel);
                    $('<colgroup><col width="50"><col width="50%"><col width="50"><col width="50%"></colgroup>').appendTo(codeTable);
                    var codeBody = $('<tbody>').appendTo(codeTable);
                    var diffSummary = diffText(textA || "", textB || "");
                    var aIndex = 0;
                    var bIndex = 0;
                    var diffLength = Math.max(diffSummary.a.length, diffSummary.b.length);

                    var diffLines = [];
                    var diffBlocks = [];
                    var currentBlock;
                    var blockLength = 0;
                    var blockType = 0;

                    for (var i = 0; i < diffLength; i++) {
                        var diffLine = diffSummary[i];
                        var Adiff = (aIndex < diffSummary.a.length) ? diffSummary.a[aIndex] : { type: 2, line: "" };
                        var Bdiff = (bIndex < diffSummary.b.length) ? diffSummary.b[bIndex] : { type: 2, line: "" };
                        if (Adiff.type === 0 && Bdiff.type !== 0) {
                            Adiff = { type: 2, line: "" };
                            bIndex++;
                        } else if (Bdiff.type === 0 && Adiff.type !== 0) {
                            Bdiff = { type: 2, line: "" };
                            aIndex++;
                        } else {
                            aIndex++;
                            bIndex++;
                        }
                        diffLines.push({
                            a: Adiff,
                            b: Bdiff
                        });
                        if (currentBlock === undefined) {
                            currentBlock = { start: i, end: i };
                            blockLength = 0;
                            blockType = (Adiff.type === 0 && Bdiff.type === 0) ? 0 : 1;
                        } else {
                            if (Adiff.type === 0 && Bdiff.type === 0) {
                                // Unchanged line
                                if (blockType === 0) {
                                    // still unchanged - extend the block
                                    currentBlock.end = i;
                                    blockLength++;
                                } else if (blockType === 1) {
                                    // end of a change
                                    currentBlock.end = i;
                                    blockType = 2;
                                    blockLength = 0;
                                } else if (blockType === 2) {
                                    // post-change unchanged
                                    currentBlock.end = i;
                                    blockLength++;
                                    if (blockLength === 8) {
                                        currentBlock.end -= 5; // rollback the end
                                        diffBlocks.push(currentBlock);
                                        currentBlock = { start: i - 5, end: i - 5 };
                                        blockType = 0;
                                        blockLength = 0;
                                    }
                                }
                            } else {
                                // in a change
                                currentBlock.end = i;
                                blockLength++;
                                if (blockType === 0) {
                                    if (currentBlock.end > 3) {
                                        currentBlock.end -= 3;
                                        currentBlock.empty = true;
                                        diffBlocks.push(currentBlock);
                                        currentBlock = { start: i - 3, end: i - 3 };
                                    }
                                    blockType = 1;
                                } else if (blockType === 2) {
                                    // we were in unchanged, but hit a change again
                                    blockType = 1;
                                }
                            }
                        }
                    }
                    if (blockType === 0) {
                        currentBlock.empty = true;
                    }
                    currentBlock.end = diffLength;
                    diffBlocks.push(currentBlock);
                    console.table(diffBlocks);
                    var diffRow;
                    for (var b = 0; b < diffBlocks.length; b++) {
                        currentBlock = diffBlocks[b];
                        if (currentBlock.empty) {
                            diffRow = createExpandLine(currentBlock.start, currentBlock.end, diffLines).appendTo(codeBody);
                        } else {
                            for (var i = currentBlock.start; i < currentBlock.end; i++) {
                                var row = createDiffLine(diffLines[i]).appendTo(codeBody);
                                if (i === currentBlock.start) {
                                    row.addClass("start-block");
                                } else if (i === currentBlock.end - 1) {
                                    row.addClass("end-block");
                                }
                            }
                        }
                    }

                },
                close: function () {
                    diffVisible = false;

                },
                show: function () {

                }
            }
            RED.tray.show(trayOptions);




            /*             var trayOptions = {
                            title: RED._("diff.viewCommitDiff"),
                            width: Infinity,
                            overlay: true,
                            buttons: [
                                {
                                    text: RED._("common.label.close"),
                                    click: function() {
                                        RED.tray.close();
                                    }
                                }
                            ],
                            resize: function(dimensions) {
                                // trayWidth = dimensions.width;
                            },
                            open: function(tray) {
                                var trayBody = tray.find('.red-ui-tray-body');
                                var diffPanel = $('<div class="red-ui-diff-text"></div>').appendTo(trayBody);
                
                                var codeTable = $("<table>",{class:"red-ui-diff-text-content"}).appendTo(diffPanel);
                                $('<colgroup><col width="50"><col width="50"><col width="100%"></colgroup>').appendTo(codeTable);
                                var codeBody = $('<tbody>').appendTo(codeTable);
                
                                var diffRow = $('<tr class="red-ui-diff-text-commit-header">').appendTo(codeBody);
                                var content = $('<td colspan="3"></td>').appendTo(diffRow);
                
                                $("<h3>").text("commit.title").appendTo(content);
                                $('<div class="commit-body"></div>').text("commit.comment").appendTo(content);
                                var summary = $('<div class="commit-summary"></div>').appendTo(content);
                                $('<div style="float: right">').text("Commit ").appendTo(summary);
                                $('<div>').text(" - ").appendTo(summary);
                
                
                
                            },
                            close: function() {
                                diffVisible = false;
                            },
                            show: function() {
                
                            }
                        }
                        RED.tray.show(trayOptions); */












        });
        XAPP.actions.add("core:toggle-toolbar-edit", function () {
            //MMaher
            console.log('treeNodes.actions.getSelectedNodeId :', treeNodes.actions.getSelectedNodeId());
            var report = {}
            var id = treeNodes.actions.getSelectedNodeId();
            var node = RED.nodes.node(id);
            if (node) {
                report.id = node.id;
                report.width = node.width;
                report.height = node.height;
                report.widget = [];
                RED.nodes.eachNode(function (node) {
                    if (node.parentid === report.id) {
                        report.widget.push(
                            {
                                id: node.id,
                                name: node.name,
                                width: node.width,
                                height: node.height,
                                x: node.x,
                                y: node.y
                            }
                        )
                    }

                });
            }
            console.log('Report :', report)
            var options = {

                // Export options
                //directory: "/tmp",       // The directory the file gets written into if not using .toFile(filename, callback). default: '/tmp'

                // Papersize Options: http://phantomjs.org/api/webpage/property/paper-size.html




                // Rendering options
                //base: "file:///home/www/your-asset-path", // Base path that's used to load files (images, css, js) when they aren't referenced using a host

                // Zooming option, can be used to scale images if `options.type` is not pdf
                //zoomFactor: "1", // default is 1

                // File options
                type: 'pdf',             // allowed file types: png, jpeg, pdf
                //quality: "75",           // only used for types png & jpeg

                // Script options
                //phantomPath: "./node_modules/phantomjs/bin/phantomjs", // PhantomJS binary which should get downloaded automatically
                //phantomArgs: [], // array of strings used as phantomjs args e.g. ["--ignore-ssl-errors=yes"]
                //script: '/url',           // Absolute path to a custom phantomjs script, use the file in lib/scripts as example
                //timeout: 30000,           // Timeout that will cancel phantomjs, in milliseconds



            }
            var msg = {
                filename: './node.pdf',
                options: {
                    //directory: "/tmp", 
                    format: 'A4', // allowed units: A3, A4, A5, Legal, Letter, Tabloid
                    orientation: 'portrait', // portrait or landscape
                    paginationOffset: 1,       // Override the initial pagination number
                    border: "0",             // default is 0, units: mm, cm, in, px
                    /*                     border: {
                                            top: "2in",            // default is 0, units: mm, cm, in, px
                                            right: "1in",
                                            bottom: "2in",
                                            left: "1.5in"
                                        }, */
                    header: {
                        height: "10mm",
                        contents: '<div style="text-align: center;">Author: Marc Bachmann</div>'
                    },
                    footer: {
                        height: "10mm",
                        contents: '<div style="text-align: center;">Author: Marc Bachmann</div>'
                    },
                    type: 'pdf',             // allowed file types: png, jpeg, pdf
                    quality: "75",           // only used for types png & jpeg
                    base: "./template", // Base path that's used to load files (images, css, js) when they aren't referenced using a host
                    // HTTP Headers that are used for requests
                    httpHeaders: {
                        // e.g.
                        Authorization: "Bearer ACEFAD8C-4B4D-4042-AB30-6C735F5BAC8B"
                    },

                    // To run Node application as Windows service
                    childProcessOptions: {
                        detached: true
                    },
                    // Time we should wait after window load
                    // accepted values are 'manual', some delay in milliseconds or undefined to wait for a render event
                    renderDelay: 1000,


                    // HTTP Cookies that are used for requests
                    httpCookies: [
                        // e.g.
                        {
                            name: "Valid-Cookie-Name", // required
                            value: "Valid-Cookie-Value", // required
                            domain: "localhost",
                            path: "/foo", // required
                            httponly: true,
                            secure: false,
                            expires: (new Date()).getTime() + (1000 * 60 * 60) // e.g. expires in 1 hour
                        },
                    ]

                },
                payload: `<div class="profile_info">
                                <span>Welcome,</span>
                                <h2>John Doe</h2>
                            </div>`
            };

            //msg.payload = $('.card-body').html();
            console.log("msg.payload  :", msg.payload)
            $.ajax({
                method: 'POST',
                xhrFields: {
                    responseType: 'blob'
                },
                contentType: 'application/json',
                url: "GenPDF",
                data: JSON.stringify(report),
                success: function (data) {

                    var blob = new Blob([data]);
                    var url = window.webkitURL.createObjectURL(blob);

                    var element = document.createElement('a');
                    element.setAttribute('href', url);
                    element.setAttribute('download', "report.pdf");
                    element.style.display = 'none';
                    document.body.appendChild(element);
                    element.click();
                    document.body.removeChild(element);
                    window.URL.revokeObjectURL(url);


                },
                error: function (jqXHR, textStatus, errorThrown) {
                    RED.notify("Problme d'ecriture"/* RED._("inject tags.success") */);
                }
            });




        });
        XAPP.actions.add("core:toggle-toolbar-trash", function () {
            //trash

            function buildbody(body, data) {
                var diffList = $('<ol class="red-ui-diff-list"></ol>').appendTo(body);
                diffList.editableList({
                    addButton: false,
                    height: "auto",
                    scrollOnAdd: false,
                    addItem: function (container, i, data) {
                        var item = $(`
                                    <tr>
                                        <td>Item 01</td>
                                        <td>--</td>
                                        <td>--</td>
                                    </tr>
                                  `).appendTo(container)
                    }


                });
                var id = 0;
                var data = []
                diffList.editableList('addItem', { i: id, item: data });
                diffList.editableList('addItem', { i: id, item: data });
                /* return diffList; */
            }
            function buildPanel(container, data) {
                var diffPanel = $('<div class="red-ui-diff-panel red-ui-diff-panel-merge red-ui-diff-three-way"></div>').appendTo(container);
                var diffHeaders = $(`<div class="red-ui-diff-panel-headers">
                                        <div>Start Date</div>
                                        <div>End Date</div>
                                        <div>Duree</div>
                                    </div>
                                    `).appendTo(diffPanel);
                /* var diffList =  */createTable(diffPanel, data);
                /* return diffList; */
            }

            function createNodePropertiesTable() {
                var nodePropertiesDiv = $("<div>", { class: "red-ui-list-node-properties" });
                /*  var table_container = $(`<div class="vallis" style="width:100%">`).appendTo(nodePropertiesDiv) */
                var container = $(`
                            <div class="red-ui-list-node-properties-container">
                                <div>id</div>
                                <div>1</div>
                                <div>2</div>
                                <div>3</div>
                                <div>4</div>
                                <div>5</div>
                                <div>6</div>
                            </div>
                            `).appendTo(nodePropertiesDiv);
                var container = $(`
                            <div class="red-ui-list-node-properties-container">
                                <div>id</div>
                                <div>1</div>
                                <div>2</div>
                                <div>3</div>
                                <div>4</div>
                                <div>5</div>
                                <div>6</div>
                            </div>
                            `).appendTo(nodePropertiesDiv);
                return nodePropertiesDiv;
            }
            var container = $('#system-main-container');
            container.empty()

            var pannel = $(`<div class="red-ui-editableList-panel">`).appendTo(container)

            var pannel_header = $(`<div class="red-ui-panel-headers">
                                       <div>Breifing</div>
                                       <div>Date</div>
                                       <div>From</div>
                                       <div>To</div>
                                       <div>Duree</div>
                                       <div>status</div>
                                    </div>`).appendTo(pannel)
            var editablelist = $(`<div class="red-ui-editableList">`).appendTo(pannel);
            var item = $(`<div class="red-ui-editableList-border red-ui-editableList-container" style="max-height: none;">`).appendTo(editablelist)
            var ol = $(`<ol class="red-ui-list">`).appendTo(item)
            ol.editableList({
                addButton: false,
                height: "auto",
                scrollOnAdd: false,
                addItem: function (container, i, object) {

                    var tabDiv = $('<div>', { class: "red-ui-list-flow" }).appendTo(container);
                    tabDiv.addClass('collapsed');


                    var titleRow = $('<div>', { class: "red-ui-list-flow-title" }).appendTo(tabDiv);
                    var nodesDiv = $('<div>').appendTo(tabDiv);
                    var originalCell = $('<div>', { class: "red-ui-list-node-cell" }).appendTo(titleRow);
                    var localCell = $('<div>', { class: "red-ui-list-node-cell red-ui-list-node-local" }).appendTo(titleRow);
                    var remoteCell = $('<div>', { class: "red-ui-list-node-cell red-ui-list-node-remote" }).appendTo(titleRow);
                    var remoteCell = $('<div>', { class: "red-ui-list-node-cell red-ui-list-node-remote" }).appendTo(titleRow);
                    var remoteCell = $('<div>', { class: "red-ui-list-node-cell red-ui-list-node-remote" }).appendTo(titleRow);
                    var remoteCell = $('<div>', { class: "red-ui-list-node-cell red-ui-list-node-remote" }).appendTo(titleRow);
                    var remoteCell = $('<div>', { class: "red-ui-list-node-cell red-ui-list-node-remote" }).appendTo(titleRow);
                    $('<span class="red-ui-list-chevron"><i class="fa fa-angle-down"></i></span>').appendTo(originalCell);

                    var div = $("<div>", { class: "red-ui-list-node collapsed" }).appendTo(nodesDiv);
                    var row = $("<div>", { class: "red-ui-list-node-header" }).appendTo(div);
                    var originalNodeDiv = $("<div>", { class: "red-ui-list-node-cell" }).appendTo(row);
                    var localNodeDiv = $("<div>", { class: "" }).appendTo(row);

                    var remoteNodeDiv = $("<div>", { class: "" }).appendTo(row);

                    var remoteNodeDiv = $("<div>", { class: "" }).appendTo(row);
                    var remoteNodeDiv = $("<div>", { class: "" }).appendTo(row);
                    var remoteNodeDiv = $("<div>", { class: "" }).appendTo(row);
                    var remoteNodeDiv = $("<div>", { class: "" }).appendTo(row);
                    remoteNodeDiv.addClass("red-ui-empty");
                    localNodeDiv.addClass("red-ui-empty");
                    $('<span class="red-ui-list-chevron"><i class="fa fa-angle-down"></i></span>').appendTo(originalNodeDiv);
                    $('<span>').text(RED._("diff.flowProperties")).appendTo(originalNodeDiv);

                    row.on("click", function (evt) {
                        evt.preventDefault();
                        $(this).parent().toggleClass('collapsed');
                        if ($(this).siblings('.red-ui-list-node-properties').length === 0) {

                            createNodePropertiesTable().appendTo(div);
                        }
                    });






                    titleRow.on("click", function (evt) {
                        // if (titleRow.parent().find(".red-ui-list-node:not(.hide)").length > 0) {
                        titleRow.parent().toggleClass('collapsed');
                        if ($(this).parent().hasClass('collapsed')) {
                            $(this).parent().find('.red-ui-list-node').addClass('collapsed');
                            $(this).parent().find('.red-ui-debug-msg-element').addClass('collapsed');
                        }
                        // }
                    })
                }

            });

            var el = {
                /* diff: localDiff, */
                def: {
                    category: 'config',
                    color: '#f0f0f0'
                },
                tab: {
                    n: {},
                    /* nodes: currentConfig.globals */
                },
                newTab: {
                    n: {},
                    /* nodes: newConfig.globals */
                }
            };

            ol.editableList('addItem', el);
            ol.editableList('addItem', el);
            ol.editableList('addItem', el);
            ol.editableList('addItem', el);

        });
        XAPP.actions.add("core:toggle-toolbar-checkin", function () {
            console.log('console.log("core:toggle-toolbar-checkin")  hhh')
        });
        XAPP.actions.add("core:toggle-toolbar-default", function () { console.log("core:toggle-toolbar-default") });
        XAPP.actions.add("core:toggle-toolbar-refresh", function () {
            //DateMaher
            console.log('Gen Data')



            $.ajax({
                method: 'POST',
                contentType: 'application/json',
                url: "/insertdates/",
                data: JSON.stringify({}),
                success: function (resp) {
                    RED.notify(RED._("inject tags.success"));
                },
                error: function (jqXHR, textStatus, errorThrown) {

                }
            });


        });
        XAPP.actions.add("core:toggle-toolbar-publish", function () { console.log("core:toggle-toolbar-publish") });
        XAPP.actions.add("core:toggle-toolbar-unpublish", function () { console.log("core:toggle-toolbar-unpublish") });
        XAPP.actions.add("core:toggle-toolbar-options", function () { console.log("core:toggle-toolbar-options") });
        XAPP.actions.add("core:toggle-toolbar-help", function () { console.log("core:toggle-toolbar-help") });
        createToolbar(container, toolbarOptions)


    }

    function init(options) {

        var toolbar_container = $(`
                                    <!-- Subheader -->
                                    <div class="j-subhead hidden-tablet hidden-phone">
                                        <div class="j-container-fluid">
                                            <div id="container-collapse" class="container-collapse"></div>
                                            <div class="j-row-fluid">
                                                <div class="span12">
                                                    <!-- target for skip to content link -->
                                                    <a id="skiptarget" class="element-invisible">Main content begins here</a>
                                                    <div class="j-btn-toolbar" role="toolbar" aria-label="Toolbar" id="j-toolbar">
                                                        <div id="toolbar-deploy" class="j-btn-wrapper"></div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="header-control-down"><i class="fa fa-chevron-down"></i></div>
                                    </div>
                                    <!-- End Subheader -->
                                `).appendTo(options.target)
        RED.deploy.init(RED.settings.theme("deployButton", null));
        buildtoolbar();

    }
    return {
        init: init,
    }
})();

XAPP.status = (function () {
    var menuItems = {};

    function triggerAction(id, args) {
        callback = XAPP.actions.get(id);

        if (callback) {
            callback.call(id, args);
        } else {
            console.log("No callback for", id, opt.onselect);
        }
    }

    function buildstatus() {
        var statusOptions = [];
        var container = $("#j-status")
        statusOptions.push({ id: "status-item-connections", label: "Connections", display: true, link: false, value: 0, icon: 'badge', class: "badge" });
        statusOptions.push({ id: "status-item-nodes", label: "Nodes", display: true, link: false, value: 0, icon: 'badge', class: "badge" });
        statusOptions.push({ id: "status-item-messages", label: "Messages", display: true, link: false, value: 2, icon: 'badge', class: "badge", onselect: "core:toggle-messages" });
        statusOptions.push({ id: "status-item-logout", label: "Log out", display: true, link: true, icon: 'j-icon-minus-2', class: "j-icon-minus-2", onselect: "core:user-log-out" });

        var item = $('<div class="j-btn-toolbar"></div>');

        for (var i = 0; i < statusOptions.length; i++) {
            var opt = statusOptions[i]

            if (!opt.link) {
                var btn = $('<div class="j-btn-group"><span id="' + opt.id + '" class="' + opt.class + '">' + opt.value + '</span>' + opt.label + '<span class="j-btn-group separator"></span></div>').appendTo(item);
            } else {
                var btn = $('<div class="j-btn-group"><a href="#"><span id="' + opt.id + '" class="' + opt.class + '">' + (opt.value ? opt.value : '') + '</span>' + opt.label + '</a><span class="j-btn-group separator"></span></div>').appendTo(item);


                if (opt.onselect) {
                    btn.on("click", function (e) {
                        e.preventDefault();
                        triggerAction(opt.onselect);
                    })
                }
            }



        }
        container.append(item)


    }
    function setConnection(val) {
        $("#status-item-connections").text(val);
    }
    function init(options) {
        var status_container = $(`
                                    <!-- Status Module -->
                                    <div id="j-status" class="j-navbar j-navbar-fixed-bottom hidden-phone">
                                        <div class="j-btn-toolbar">
                                            <div class="j-btn-group pull-right">
                                                <p>
                                                    XAPP ! 4.0.2 &nbsp;&nbsp;  2024 Siemens S7
                                                </p>
                                            </div>
                                        </div>
                                    </div>
                                    <!-- Status Module -->
                                `).appendTo(options.target)


        buildstatus();
    }
    return {
        init: init,
    }
})();

XAPP.dialog = (function () {

    var dialog;
    var dialogContainer;
    var exportNodesDialog;
    var importNodesDialog;
    var disabled = false;
    var popover;
    var currentPopoverError;
    var activeTab;
    var libraryBrowser;
    var examplesBrowser;
    //Maher Import
    function importData(data, z) {
        var n = {}
        for (var i = 0; i < data.length; i++) {
            var node = data[i];
            switch (node.type) {
                case 's7.config':

                    n = {
                        id: node.id, type: node.type, name: node.name, topic: node.topic, ip: node.ip, port: node.port, rack: node.rack, slot: node.slot,
                        cycletime: node.cycletime, timeout: node.timeout, verbose: node.verbose, class: "icon-connection", users: [], payload: {}
                    }
                    break;
                case 's7.group':
                    n = { id: node.id, type: node.type, connection: node.connection, name: node.name, topic: node.topic, class: "icon-group", users: [] }
                    break;
                case 's7.io':
                    var _id;
                    if (node.id) {

                        _id = node.id;
                    } else {
                        _id = RED.nodes.id();
                        console.log('ID :', _id)
                    }
                    data[i].id = _id;
                    n = {
                        id: _id, type: node.type, z: z, connection: node.connection, name: node.name, payload: node.payload
                        , group: node.group, topic: node.topic, none: node.none, repeat: node.repeat, db: node.db, operation: node.operation,
                        dbnone: node.dbnone, dbrepeat: node.dbrepeat, once: node.once, maxvalue: node.maxvalue, color: node.color, unit: node.unit, class: "icon-tag", x: 0, y: 0
                    }
                    break;
                default:
                    var n = {}
            }

            n._def = RED.nodes.getType(n.type);
            RED.nodes.add(n);
            RED.nodes.dirty(true);

            if (node.children && node.children.length > 0) {
                importData(node.children, z)
            }

        }
    }
    function setupDialogs() {
        dialog = $('<div id="red-ui-dialog" class="hide"><form class="dialog-form form-horizontal"></form></div>')
            .appendTo("#red-ui-editor")
            .dialog({
                modal: true,
                autoOpen: false,
                width: 700,
                resizable: false,
                classes: {
                    "ui-dialog": "red-ui-editor-dialog",
                    "ui-dialog-titlebar-close": "hide",
                    "ui-widget-overlay": "red-ui-editor-dialog"
                },
                buttons: [
                    {
                        id: "red-ui-dialog-cancel",
                        text: RED._("common.label.cancel"),
                        click: function () {
                            $(this).dialog("close");
                        }
                    },
                    {
                        id: "red-ui-dialog-download",
                        class: "primary",
                        text: RED._("clipboard.download"),
                        click: function () {
                            var element = document.createElement('a');
                            element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent($("#red-ui-dialog-export-text").val()));
                            element.setAttribute('download', "Config.json");
                            element.style.display = 'none';
                            document.body.appendChild(element);
                            element.click();
                            document.body.removeChild(element);
                            $(this).dialog("close");
                        }
                    },
                    {
                        id: "red-ui-dialog-ok",
                        class: "primary",
                        text: RED._("common.label.import"),
                        click: function () {

                            var v = $("#red-ui-dialog-import-text").val().trim();
                            var res = JSON.parse(v);
                            var z = XAPP.treelist.actions.getWorkspaceId();


                            importData(res, z)


                            var Tree = XAPP.treelist.tree();
                            Tree.addNodes(Tree.getSelectedNodes()[0], res);

                            $(this).dialog("close");
                        }
                    }
                ],
                close: function (e) {
                    if (popover) {
                        popover.close(true);
                        currentPopoverError = null;
                    }
                }
            });

        dialogContainer = dialog.children(".dialog-form");


        exportNodesDialog =
            `<div class="red-ui-clipboard-dialog-box">
                                <div id="red-ui-dialog-export-tab-clipboard" class="red-ui-clipboard-dialog-tab-clipboard">
                                    <div class="form-row">
                                        <textarea readonly id="red-ui-dialog-export-text"></textarea>
                                    </div>
                                    <div class="form-row" style="text-align: right;">
                                        <span id="red-ui-dialog-export-fmt-group" class="button-group">
                                            <a id="red-ui-dialog-export-fmt-mini" class="red-ui-button red-ui-button-small toggle" href="#" data-i18n="clipboard.export.compact"></a>
                                            <a id="red-ui-dialog-export-fmt-full" class="red-ui-button red-ui-button-small toggle" href="#" data-i18n="clipboard.export.formatted"></a>
                                        </span>
                                    </div>
                                </div>
                        </div>`
            ;

        importNodesDialog =
            `<div class="red-ui-clipboard-dialog-box" style="margin-bottom: 12px;">
                <div id="red-ui-dialog-import-tab-clipboard" class="red-ui-clipboard-dialog-tab-clipboard">
                    <div class="form-row">
                        <span data-i18n="clipboard.pasteNodes"></span>
                        <a class="red-ui-button" id="red-ui-dialog-import-file-upload-btn"><i class="fa fa-upload"></i> <span data-i18n="clipboard.selectFile"></span></a>
                        <input type="file" id="red-ui-dialog-import-file-upload" accept=".json" style="display: none;" />
                    </div>
                    <div class="form-row">
                        <textarea id="red-ui-dialog-import-text"></textarea>
                    </div>
                </div>
            </div>`
    }


    var validateExportFilenameTimeout
    function validateExportFilename() {
        if (validateExportFilenameTimeout) {
            clearTimeout(validateExportFilenameTimeout);
        }
        validateExportFilenameTimeout = setTimeout(function () {
            var filenameInput = $("#red-ui-dialog-tab-library-name");
            var filename = filenameInput.val().trim();
            var valid = filename.length > 0 && !/[\/\\]/.test(filename);
            if (valid) {
                filenameInput.removeClass("input-error");
                $("#red-ui-dialog-export").button("enable");
            } else {
                filenameInput.addClass("input-error");
                $("#red-ui-dialog-export").button("disable");
            }
        }, 100);
    }
    var validateImportTimeout;
    function validateImport() {

        if (validateImportTimeout) {
            clearTimeout(validateImportTimeout);
        }
        validateImportTimeout = setTimeout(function () {
            var importInput = $("#red-ui-dialog-import-text");
            var v = importInput.val().trim();
            if (v === "") {
                popover.close(true);
                currentPopoverError = null;
                importInput.removeClass("input-error");
                $("#red-ui-dialog-ok").button("disable");
                return;
            }
            try {
                if (!/^\[[\s\S]*\]$/m.test(v)) {
                    throw new Error(RED._("clipboard.import.errors.notArray"));
                }
                var res = JSON.parse(v);
                for (var i = 0; i < res.length; i++) {
                    if (typeof res[i] !== "object") {
                        throw new Error(RED._("clipboard.import.errors.itemNotObject", { index: i }));
                    }

                }
                currentPopoverError = null;
                popover.close(true);
                importInput.removeClass("input-error");
                importInput.val(v);
                $("#red-ui-dialog-ok").button("enable");
            } catch (err) {
                if (v !== "") {
                    importInput.addClass("input-error");
                    var errString = err.toString();
                    if (errString !== currentPopoverError) {
                        // Display the error as-is.
                        // Error messages are only in English. Each browser has its
                        // own set of messages with very little consistency.
                        // To provide translated messages this code will either need to:
                        // - reduce everything down to 'unexpected token at position x'
                        //   which is the least useful, but most consistent message
                        // - use a custom/library parser that gives consistent messages
                        //   which can be translated.
                        var message = $('<div class="red-ui-clipboard-import-error"></div>').text(errString);
                        var errorPos;
                        // Chrome error messages
                        var m = /at position (\d+)/i.exec(errString);
                        if (m) {
                            errorPos = parseInt(m[1]);
                        } else {
                            // Firefox error messages
                            m = /at line (\d+) column (\d+)/i.exec(errString);
                            if (m) {
                                var line = parseInt(m[1]) - 1;
                                var col = parseInt(m[2]) - 1;
                                var lines = v.split("\n");
                                errorPos = 0;
                                for (var i = 0; i < line; i++) {
                                    errorPos += lines[i].length + 1;
                                }
                                errorPos += col;
                            } else {
                                // Safari doesn't provide any position information
                                // IE: tbd
                            }
                        }

                        if (errorPos !== undefined) {
                            v = v.replace(/\n/g, "");
                            var index = parseInt(m[1]);
                            var parseError = $('<div>').appendTo(message);
                            var code = $('<pre>').appendTo(parseError);
                            $('<span>').text(v.substring(errorPos - 12, errorPos)).appendTo(code)
                            $('<span class="error">').text(v.charAt(errorPos)).appendTo(code);
                            $('<span>').text(v.substring(errorPos + 1, errorPos + 12)).appendTo(code);
                        }
                        popover.close(true).setContent(message).open();
                        currentPopoverError = errString;
                    }
                } else {
                    currentPopoverError = null;
                }
                $("#red-ui-dialog-ok").button("disable");
            }
        }, 100);

    }
    //importNodes
    function importNodes(mode) {
        if (disabled) {
            return;
        }
        mode = mode || "clipboard";

        dialogContainer.empty();
        dialogContainer.append($(importNodesDialog));

        $("#red-ui-dialog-ok").show();
        $("#red-ui-dialog-cancel").show();
        $("#red-ui-dialog-download").hide();
        $("#red-ui-dialog-ok").button("disable");

        dialogContainer.i18n();
        $("#red-ui-dialog-import-text").on("keyup", validateImport);
        $("#red-ui-dialog-import-text").on('paste', function () { setTimeout(validateImport, 10) });

        $("#red-ui-dialog-import-file-upload").on("change", function () {
            var fileReader = new FileReader();
            fileReader.onload = function () {
                $("#red-ui-dialog-import-text").val(fileReader.result);
                validateImport();
            };
            fileReader.readAsText($(this).prop('files')[0]);
        })
        $("#red-ui-dialog-import-file-upload-btn").on("click", function (evt) {
            evt.preventDefault();
            $("#red-ui-dialog-import-file-upload").trigger("click");
        })



        setTimeout(function () {
            $("#red-ui-dialog-import-text").trigger("focus");
        }, 100)



        dialog.dialog("option", "title", RED._("clipboard.importNodes")).dialog("open");
        popover = RED.popover.create({
            target: $("#red-ui-dialog-import-text"),
            trigger: "manual",
            direction: "bottom",
            content: ""
        });
    }

    function genData(data) {
        var n = {}
        var nodes = [];
        for (var i = 0; i < data.length; i++) {
            var nn = data[i];
            if (RED.nodes.node(nn.id)) {
                var node = RED.nodes.node(nn.id)
                switch (node.type) {
                    case 's7.config':
                        n = {
                            id: node.id, type: node.type, name: node.name, topic: node.topic, ip: node.ip, port: node.port, rack: node.rack, slot: node.slot,
                            cycletime: node.cycletime, timeout: node.timeout, verbose: node.verbose, class: "icon-connection"
                        }
                        break;
                    case 's7.group':
                        n = { id: node.id, type: node.type, connection: node.connection, name: node.name, topic: node.topic, class: "icon-group" }
                        break;
                    case 's7.io':
                        n = {
                            id: node.id, type: node.type, z: node.z, connection: node.connection, name: node.name, payload: node.payload
                            , group: node.group, topic: node.topic, none: node.none, repeat: node.repeat, db: node.db, operation: node.operation,
                            dbnone: node.dbnone, dbrepeat: node.dbrepeat, once: node.once, maxvalue: node.maxvalue, color: node.color, unit: node.unit, class: "icon-tag"
                        }
                        break;
                    default:
                        var n = {}
                }

                if (nn.children && nn.children.length > 0) {
                    console.log("With Children", nn.children)
                    n.children = genData(nn.children);
                }
            }

            nodes.push(n)
        }

        return nodes;
    }

    function exportNodes(Tree) {
        if (disabled) {
            return;
        }



        dialogContainer.empty();
        dialogContainer.append($(exportNodesDialog));



        $("#red-ui-dialog-tab-library-name").on("keyup", validateExportFilename);
        $("#red-ui-dialog-tab-library-name").on('paste', function () { setTimeout(validateExportFilename, 10) });
        $("#red-ui-dialog-export").button("enable");

        $("#red-ui-dialog-tab-library-name").val("flows.json").select();

        dialogContainer.i18n();
        var format = RED.settings.flowFilePretty ? "red-ui-dialog-export-fmt-full" : "red-ui-dialog-export-fmt-mini";
        var nn = Tree.getSelectedNodes();

        var nodes = []
        nodes = genData(nn);

        format = $(this).attr('id');
        if (format === 'red-ui-dialog-export-fmt-full') {
            flow = JSON.stringify(nodes, null, 4);
        } else {
            flow = JSON.stringify(nodes);
        }
        $("#red-ui-dialog-export-text").val(flow);
        setTimeout(function () { $("#red-ui-dialog-export-text").scrollTop(0); }, 50);

        $("#red-ui-dialog-export-text").trigger("focus");

        $("#red-ui-dialog-export-fmt-group > a").on("click", function (evt) {
            evt.preventDefault();
            if ($(this).hasClass('disabled') || $(this).hasClass('selected')) {
                $("#red-ui-dialog-export-text").trigger("focus");
                return;
            }
            $(this).parent().children().removeClass('selected');
            $(this).addClass('selected');

            var flow = $("#red-ui-dialog-export-text").val();
            if (flow.length > 0) {
                var nodes = JSON.parse(flow);

                format = $(this).attr('id');
                if (format === 'red-ui-dialog-export-fmt-full') {
                    flow = JSON.stringify(nodes, null, 4);
                } else {
                    flow = JSON.stringify(nodes);
                }
                $("#red-ui-dialog-export-text").val(flow);
                setTimeout(function () { $("#red-ui-dialog-export-text").scrollTop(0); }, 50);

                $("#red-ui-dialog-export-text").trigger("focus");
            }
        });

        $("#red-ui-dialog-export-rng-group > a").on("click", function (evt) {
            evt.preventDefault();
            if ($(this).hasClass('disabled') || $(this).hasClass('selected')) {
                return;
            }
            $(this).parent().children().removeClass('selected');
            $(this).addClass('selected');
            var type = $(this).attr('id');
            var flow = "";
            var nodes = null;
            if (type === 'red-ui-dialog-export-rng-selected') {
                var selection = RED.workspaces.selection();
                if (selection.length > 0) {
                    nodes = [];
                    selection.forEach(function (n) {
                        nodes.push(n);
                        nodes = nodes.concat(RED.nodes.filterNodes({ z: n.id }));
                    });
                } else {
                    nodes = RED.view.selection().nodes || [];
                }
                // Don't include the subflow meta-port nodes in the exported selection
                //  nodes = RED.nodes.createExportableNodeSet(nodes.filter(function (n) { return n.type !== 'subflow' }));
            } else if (type === 'red-ui-dialog-export-rng-flow') {
                var activeWorkspace = RED.workspaces.active();
                nodes = RED.nodes.filterNodes({ z: activeWorkspace });
                var parentNode = RED.nodes.workspace(activeWorkspace) || RED.nodes.subflow(activeWorkspace);
                nodes.unshift(parentNode);
                // nodes = RED.nodes.createExportableNodeSet(nodes);
            } else if (type === 'red-ui-dialog-export-rng-full') {
                nodes = RED.nodes.createCompleteNodeSet(false);
            }
            if (nodes !== null) {
                if (format === "red-ui-dialog-export-fmt-full") {
                    flow = JSON.stringify(nodes, null, 4);
                } else {
                    flow = JSON.stringify(nodes);
                }
            }
            if (flow.length > 0) {
                $("#red-ui-dialog-export").removeClass('disabled');
            } else {
                $("#red-ui-dialog-export").addClass('disabled');
            }
            $("#red-ui-dialog-export-text").val(flow);
            setTimeout(function () { $("#red-ui-dialog-export-text").scrollTop(0); }, 50);
            $("#red-ui-dialog-export-text").trigger("focus");
        })

        $("#red-ui-dialog-ok").hide();
        $("#red-ui-dialog-cancel").hide();
        $("#red-ui-dialog-download").hide();

        var selection = RED.workspaces.selection();
        if (selection.length > 0) {
            $("#red-ui-dialog-export-rng-selected").trigger("click");
        } else {
            selection = RED.view.selection();
            if (selection.nodes) {
                $("#red-ui-dialog-export-rng-selected").trigger("click");
            } else {
                $("#red-ui-dialog-export-rng-selected").addClass('disabled').removeClass('selected');
                $("#red-ui-dialog-export-rng-flow").trigger("click");
            }
        }
        if (format === "red-ui-dialog-export-fmt-full") {
            $("#red-ui-dialog-export-fmt-full").trigger("click");
        } else {
            $("#red-ui-dialog-export-fmt-mini").trigger("click");
        }

        /*         libraryBrowser = RED.library.createBrowser({
                    container: $("#red-ui-dialog-export-tab-library-browser"),
                    folderTools: true,
                    onselect: function (file) {
                        if (file && file.label && !file.children) {
                            $("#red-ui-dialog-tab-library-name").val(file.label);
                        }
                    }
                })
                loadFlowLibrary(libraryBrowser, "local", RED._("library.types.local"));
        
        
                var format = RED.settings.flowFilePretty ? "red-ui-dialog-export-fmt-full" : "red-ui-dialog-export-fmt-mini";
        
                $("#red-ui-dialog-export-fmt-group > a").on("click", function (evt) {
                    evt.preventDefault();
                    if ($(this).hasClass('disabled') || $(this).hasClass('selected')) {
                        $("#red-ui-dialog-export-text").trigger("focus");
                        return;
                    }
                    $(this).parent().children().removeClass('selected');
                    $(this).addClass('selected');
        
                    var flow = $("#red-ui-dialog-export-text").val();
                    if (flow.length > 0) {
                        var nodes = JSON.parse(flow);
        
                        format = $(this).attr('id');
                        if (format === 'red-ui-dialog-export-fmt-full') {
                            flow = JSON.stringify(nodes, null, 4);
                        } else {
                            flow = JSON.stringify(nodes);
                        }
                        $("#red-ui-dialog-export-text").val(flow);
                        setTimeout(function () { $("#red-ui-dialog-export-text").scrollTop(0); }, 50);
        
                        $("#red-ui-dialog-export-text").trigger("focus");
                    }
                });
        
                $("#red-ui-dialog-export-rng-group > a").on("click", function (evt) {
                    evt.preventDefault();
                    if ($(this).hasClass('disabled') || $(this).hasClass('selected')) {
                        return;
                    }
                    $(this).parent().children().removeClass('selected');
                    $(this).addClass('selected');
                    var type = $(this).attr('id');
                    var flow = "";
                    var nodes = null;
                    if (type === 'red-ui-dialog-export-rng-selected') {
                        var selection = RED.workspaces.selection();
                        if (selection.length > 0) {
                            nodes = [];
                            selection.forEach(function (n) {
                                nodes.push(n);
                                nodes = nodes.concat(RED.nodes.filterNodes({ z: n.id }));
                            });
                        } else {
                            nodes = RED.view.selection().nodes || [];
                        }
                        // Don't include the subflow meta-port nodes in the exported selection
                        nodes = RED.nodes.createExportableNodeSet(nodes.filter(function (n) { return n.type !== 'subflow' }));
                    } else if (type === 'red-ui-dialog-export-rng-flow') {
                        var activeWorkspace = RED.workspaces.active();
                        nodes = RED.nodes.filterNodes({ z: activeWorkspace });
                        var parentNode = RED.nodes.workspace(activeWorkspace) || RED.nodes.subflow(activeWorkspace);
                        nodes.unshift(parentNode);
                        nodes = RED.nodes.createExportableNodeSet(nodes);
                    } else if (type === 'red-ui-dialog-export-rng-full') {
                        nodes = RED.nodes.createCompleteNodeSet(false);
                    }
                    if (nodes !== null) {
                        if (format === "red-ui-dialog-export-fmt-full") {
                            flow = JSON.stringify(nodes, null, 4);
                        } else {
                            flow = JSON.stringify(nodes);
                        }
                    }
                    if (flow.length > 0) {
                        $("#red-ui-dialog-export").removeClass('disabled');
                    } else {
                        $("#red-ui-dialog-export").addClass('disabled');
                    }
                    $("#red-ui-dialog-export-text").val(flow);
                    setTimeout(function () { $("#red-ui-dialog-export-text").scrollTop(0); }, 50);
                    $("#red-ui-dialog-export-text").trigger("focus");
                })
        
                $("#red-ui-dialog-ok").hide();
                $("#red-ui-dialog-cancel").hide();
                $("#red-ui-dialog-export").hide();
                var selection = RED.workspaces.selection();
                if (selection.length > 0) {
                    $("#red-ui-dialog-export-rng-selected").trigger("click");
                } else {
                    selection = RED.view.selection();
                    if (selection.nodes) {
                        $("#red-ui-dialog-export-rng-selected").trigger("click");
                    } else {
                        $("#red-ui-dialog-export-rng-selected").addClass('disabled').removeClass('selected');
                        $("#red-ui-dialog-export-rng-flow").trigger("click");
                    }
                }
                if (format === "red-ui-dialog-export-fmt-full") {
                    $("#red-ui-dialog-export-fmt-full").trigger("click");
                } else {
                    $("#red-ui-dialog-export-fmt-mini").trigger("click");
                }
                tabs.activateTab("red-ui-dialog-export-tab-" + mode);
                */
        dialog.dialog("option", "title", RED._("clipboard.exportNodes")).dialog("open");

        $("#red-ui-dialog-export-text").trigger("focus");
        $("#red-ui-dialog-cancel").show();
        $("#red-ui-dialog-download").show();


    }




    function hideDropTarget() {
        $("#red-ui-drop-target").hide();
        RED.keyboard.remove("escape");
    }

    return {

        init: function () {
            setupDialogs();


        },
        import: importNodes,
        export: exportNodes,
    }
})();

XAPP.view = (function () {
    var status = {
        color: {
            "red": "#c00",
            "green": "#32CD32",
            "yellow": "#F9DF31",
            "blue": "#53A3F3",
            "grey": "#d3d3d3"
        },
        text: {
            "connected": "success",
            "connecting": "success",
            "missing configuration": "warning",
            "error": "important",
            "unknown": "important",
            "disconnected": "warning",
        },
        icon: {
            "connected": "check-circle",
            "connecting": "check",
            "missing configuration": "warning",
            "error": "times-circle",
            "unknown": "close",
            "disconnected": "bolt",
        },
    }

    function redrawStatus(node) {

        var status = {
            color: {
                "red": "#c00",
                "green": "#32CD32",
                "yellow": "#F9DF31",
                "blue": "#53A3F3",
                "grey": "#d3d3d3"
            },
            text: {
                "connected": "success",
                "connecting": "success",
                "missing configuration": "warning",
                "error": "important",
                "unknown": "important",
                "disconnected": "warning",
            },
            icon: {
                "connected": "check-circle",
                "connecting": "check",
                "missing configuration": "warning",
                "error": "times-circle",
                "unknown": "close",
                "disconnected": "bolt",
            },
        }
        var fill, text, icon;

        if (node._def.onredrawnode) { node._def.onredrawnode.call(node); }

        var id = node.id.replace('.', '-');
        var icon = $(`.${id}_icon`);
        if (icon.length > 0) {
            icon.each(function (i, el) {
                if ($(this).is("span")) {
                    $(this).css('color', status.color[node.status.fill]);
                }
            });
        }





    }

    return {
        redrawStatus: redrawStatus,
    }
})();


XAPP.demo = (function () {
    var repeat = 2000;
    var arr = ['f258fe1.4b433', 'd5b100e0.bc9bf']
    function start() {
        setInterval(function () {

        }, repeat);
    }
    function writedata(arr) {
        arr.forEach((n) => {
            $.ajax({
                method: 'POST',
                contentType: 'application/json',
                url: "tags/" + id,
                data: JSON.stringify(msg),
                success: function (resp) {
                    // RED.notify("l'criture des donnes a t effectue avec succs"/* RED._("inject tags.success") */);
                },
                error: function (jqXHR, textStatus, errorThrown) {
                    RED.notify("Problme d'ecriture"/* RED._("inject tags.success") */);
                }
            });
        })
    }


    return {
        start: start,
    }
})();
/*
* --------------------------------------------
* AdminLTE CardWidget.js
* License MIT
* --------------------------------------------
*/
var CardWidget = function ($) {
    /**
     * Constants
     * ====================================================
     */
    var NAME = 'CardWidget';
    var DATA_KEY = 'lte.cardwidget';
    var EVENT_KEY = "." + DATA_KEY;
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var Event = {
        EXPANDED: "expanded" + EVENT_KEY,
        COLLAPSED: "collapsed" + EVENT_KEY,
        MAXIMIZED: "maximized" + EVENT_KEY,
        MINIMIZED: "minimized" + EVENT_KEY,
        REMOVED: "removed" + EVENT_KEY
    };
    var ClassName = {
        CARD: 'card',
        COLLAPSED: 'collapsed-card',
        COLLAPSING: 'collapsing-card',
        EXPANDING: 'expanding-card',
        WAS_COLLAPSED: 'was-collapsed',
        MAXIMIZED: 'maximized-card'
    };
    var Selector = {
        DATA_REMOVE: '[data-card-widget="remove"]',
        DATA_COLLAPSE: '[data-card-widget="collapse"]',
        DATA_MAXIMIZE: '[data-card-widget="maximize"]',
        CARD: "." + ClassName.CARD,
        CARD_HEADER: '.card-header',
        CARD_BODY: '.card-body',
        CARD_FOOTER: '.card-footer',
        COLLAPSED: "." + ClassName.COLLAPSED
    };
    var Default = {
        animationSpeed: 'normal',
        collapseTrigger: Selector.DATA_COLLAPSE,
        removeTrigger: Selector.DATA_REMOVE,
        maximizeTrigger: Selector.DATA_MAXIMIZE,
        collapseIcon: 'fa-minus',
        expandIcon: 'fa-plus',
        maximizeIcon: 'fa-expand',
        minimizeIcon: 'fa-compress'
    };

    var CardWidget =
        /*#__PURE__*/
        function () {
            function CardWidget(element, settings) {
                this._element = element;
                this._parent = element.parents(Selector.CARD).first();

                if (element.hasClass(ClassName.CARD)) {
                    this._parent = element;
                }

                this._settings = $.extend({}, Default, settings);
            }

            var _proto = CardWidget.prototype;

            _proto.collapse = function collapse() {
                var _this = this;

                this._parent.addClass(ClassName.COLLAPSING).children(Selector.CARD_BODY + ", " + Selector.CARD_FOOTER).slideUp(this._settings.animationSpeed, function () {
                    _this._parent.addClass(ClassName.COLLAPSED).removeClass(ClassName.COLLAPSING);
                });

                this._parent.find('> ' + Selector.CARD_HEADER + ' ' + this._settings.collapseTrigger + ' .' + this._settings.collapseIcon).addClass(this._settings.expandIcon).removeClass(this._settings.collapseIcon);

                var collapsed = $.Event(Event.COLLAPSED);

                this._element.trigger(collapsed, this._parent);
            };

            _proto.expand = function expand() {
                var _this2 = this;

                this._parent.addClass(ClassName.EXPANDING).children(Selector.CARD_BODY + ", " + Selector.CARD_FOOTER).slideDown(this._settings.animationSpeed, function () {
                    _this2._parent.removeClass(ClassName.COLLAPSED).removeClass(ClassName.EXPANDING);
                });

                this._parent.find('> ' + Selector.CARD_HEADER + ' ' + this._settings.collapseTrigger + ' .' + this._settings.expandIcon).addClass(this._settings.collapseIcon).removeClass(this._settings.expandIcon);

                var expanded = $.Event(Event.EXPANDED);

                this._element.trigger(expanded, this._parent);
            };

            _proto.remove = function remove() {
                this._parent.slideUp();

                var removed = $.Event(Event.REMOVED);

                this._element.trigger(removed, this._parent);
            };

            _proto.toggle = function toggle() {
                if (this._parent.hasClass(ClassName.COLLAPSED)) {
                    this.expand();
                    return;
                }

                this.collapse();
            };

            _proto.maximize = function maximize() {
                this._parent.find(this._settings.maximizeTrigger + ' .' + this._settings.maximizeIcon).addClass(this._settings.minimizeIcon).removeClass(this._settings.maximizeIcon);

                this._parent.css({
                    'height': this._parent.height(),
                    'width': this._parent.width(),
                    'transition': 'all .15s'
                }).delay(150).queue(function () {
                    $(this).addClass(ClassName.MAXIMIZED);
                    $('html').addClass(ClassName.MAXIMIZED);

                    if ($(this).hasClass(ClassName.COLLAPSED)) {
                        $(this).addClass(ClassName.WAS_COLLAPSED);
                    }

                    $(this).dequeue();
                });

                var maximized = $.Event(Event.MAXIMIZED);

                this._element.trigger(maximized, this._parent);
            };

            _proto.minimize = function minimize() {
                this._parent.find(this._settings.maximizeTrigger + ' .' + this._settings.minimizeIcon).addClass(this._settings.maximizeIcon).removeClass(this._settings.minimizeIcon);

                this._parent.css('cssText', 'height:' + this._parent[0].style.height + ' !important;' + 'width:' + this._parent[0].style.width + ' !important; transition: all .15s;').delay(10).queue(function () {
                    $(this).removeClass(ClassName.MAXIMIZED);
                    $('html').removeClass(ClassName.MAXIMIZED);
                    $(this).css({
                        'height': 'inherit',
                        'width': 'inherit'
                    });

                    if ($(this).hasClass(ClassName.WAS_COLLAPSED)) {
                        $(this).removeClass(ClassName.WAS_COLLAPSED);
                    }

                    $(this).dequeue();
                });

                var MINIMIZED = $.Event(Event.MINIMIZED);

                this._element.trigger(MINIMIZED, this._parent);
            };

            _proto.toggleMaximize = function toggleMaximize() {
                if (this._parent.hasClass(ClassName.MAXIMIZED)) {
                    this.minimize();
                    return;
                }

                this.maximize();
            } // Private
                ;

            _proto._init = function _init(card) {
                var _this3 = this;

                this._parent = card;
                $(this).find(this._settings.collapseTrigger).click(function () {
                    _this3.toggle();
                });
                $(this).find(this._settings.maximizeTrigger).click(function () {
                    _this3.toggleMaximize();
                });
                $(this).find(this._settings.removeTrigger).click(function () {
                    _this3.remove();
                });
            } // Static
                ;

            CardWidget._jQueryInterface = function _jQueryInterface(config) {
                var data = $(this).data(DATA_KEY);

                var _options = $.extend({}, Default, $(this).data());

                if (!data) {
                    data = new CardWidget($(this), _options);
                    $(this).data(DATA_KEY, typeof config === 'string' ? data : config);
                }

                if (typeof config === 'string' && config.match(/collapse|expand|remove|toggle|maximize|minimize|toggleMaximize/)) {
                    data[config]();
                } else if (typeof config === 'object') {
                    data._init($(this));
                }
            };

            return CardWidget;
        }();
    /**
     * Data API
     * ====================================================
     */


    $(document).on('click', Selector.DATA_COLLAPSE, function (event) {
        if (event) {
            event.preventDefault();
        }

        CardWidget._jQueryInterface.call($(this), 'toggle');
    });
    $(document).on('click', Selector.DATA_REMOVE, function (event) {
        if (event) {
            event.preventDefault();
        }

        CardWidget._jQueryInterface.call($(this), 'remove');
    });
    $(document).on('click', Selector.DATA_MAXIMIZE, function (event) {
        if (event) {
            event.preventDefault();
        }

        CardWidget._jQueryInterface.call($(this), 'toggleMaximize');
    });



    /**
     * jQuery API
     * ====================================================
     */

    $.fn[NAME] = CardWidget._jQueryInterface;
    $.fn[NAME].Constructor = CardWidget;

    $.fn[NAME].noConflict = function () {
        $.fn[NAME] = JQUERY_NO_CONFLICT;
        return CardWidget._jQueryInterface;
    };

    return CardWidget;
}(jQuery);
/**
 * --------------------------------------------
 * AdminLTE CardRefresh.js
 * License MIT
 * --------------------------------------------
 */


var CardRefresh = function ($) {
    /**
     * Constants
     * ====================================================
     */
    var NAME = 'CardRefresh';
    var DATA_KEY = 'lte.cardrefresh';
    var EVENT_KEY = "." + DATA_KEY;
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var Event = {
        LOADED: "loaded" + EVENT_KEY,
        OVERLAY_ADDED: "overlay.added" + EVENT_KEY,
        OVERLAY_REMOVED: "overlay.removed" + EVENT_KEY
    };
    var ClassName = {
        CARD: 'card'
    };
    var Selector = {
        CARD: "." + ClassName.CARD,
        DATA_REFRESH: '[data-card-widget="card-refresh"]'
    };
    var Default = {
        source: '',
        sourceSelector: '',
        params: {},
        trigger: Selector.DATA_REFRESH,
        content: '.card-body',
        loadInContent: true,
        loadOnInit: true,
        responseType: '',
        overlayTemplate: '<div class="overlay"><i class="fas fa-2x fa-sync-alt fa-spin"></i></div>',
        onLoadStart: function onLoadStart() { },
        onLoadDone: function onLoadDone(response) {
            return response;
        }
    };

    var CardRefresh =
        /*#__PURE__*/
        function () {
            function CardRefresh(element, settings) {
                this._element = element;
                this._parent = element.parents(Selector.CARD).first();
                this._settings = $.extend({}, Default, settings);
                this._overlay = $(this._settings.overlayTemplate);

                if (element.hasClass(ClassName.CARD)) {
                    this._parent = element;
                }

                if (this._settings.source === '') {
                    throw new Error('Source url was not defined. Please specify a url in your CardRefresh source option.');
                }

                this._init();

                if (this._settings.loadOnInit) {
                    this.load();
                }
            }

            var _proto = CardRefresh.prototype;

            _proto.load = function load() {
                this._addOverlay();

                this._settings.onLoadStart.call($(this));

                $.get(this._settings.source, this._settings.params, function (response) {
                    if (this._settings.loadInContent) {
                        if (this._settings.sourceSelector != '') {
                            response = $(response).find(this._settings.sourceSelector).html();
                        }

                        this._parent.find(this._settings.content).html(response);
                    }

                    this._settings.onLoadDone.call($(this), response);

                    this._removeOverlay();
                }.bind(this), this._settings.responseType !== '' && this._settings.responseType);
                var loadedEvent = $.Event(Event.LOADED);
                $(this._element).trigger(loadedEvent);
            };

            _proto._addOverlay = function _addOverlay() {
                this._parent.append(this._overlay);

                var overlayAddedEvent = $.Event(Event.OVERLAY_ADDED);
                $(this._element).trigger(overlayAddedEvent);
            };

            _proto._removeOverlay = function _removeOverlay() {
                this._parent.find(this._overlay).remove();

                var overlayRemovedEvent = $.Event(Event.OVERLAY_REMOVED);
                $(this._element).trigger(overlayRemovedEvent);
            };

            // Private
            _proto._init = function _init(card) {
                var _this = this;

                $(this).find(this._settings.trigger).on('click', function () {
                    _this.load();
                });
            } // Static
                ;

            CardRefresh._jQueryInterface = function _jQueryInterface(config) {
                var data = $(this).data(DATA_KEY);

                var _options = $.extend({}, Default, $(this).data());

                if (!data) {
                    data = new CardRefresh($(this), _options);
                    $(this).data(DATA_KEY, typeof config === 'string' ? data : config);
                }

                if (typeof config === 'string' && config.match(/load/)) {
                    data[config]();
                } else if (typeof config === 'object') {
                    data._init($(this));
                }
            };

            return CardRefresh;
        }();
    /**
     * Data API
     * ====================================================
     */


    $(document).on('click', Selector.DATA_REFRESH, function (event) {
        if (event) {
            event.preventDefault();
        }

        CardRefresh._jQueryInterface.call($(this), 'load');
    });
    /**
     * jQuery API
     * ====================================================
     */

    $.fn[NAME] = CardRefresh._jQueryInterface;
    $.fn[NAME].Constructor = CardRefresh;

    $.fn[NAME].noConflict = function () {
        $.fn[NAME] = JQUERY_NO_CONFLICT;
        return CardRefresh._jQueryInterface;
    };

    return CardRefresh;
}(jQuery);

/* Node Red Dashboard Widget */
var ElementSizer = function ($) {
    $.widget("nodereddashboard.elementSizerByNum", {
        _create: function () {
            var that = this;
            var has_height = this.options.has_height;
            var pos = this.options.pos;
            var c_width = has_height ? '15%' : '6%';
            var container = $('<div>').css({
                position: 'absolute',
                background: 'white',
                padding: '10px 10px 10px 10px',
                border: '1px solid grey',
                zIndex: '20',
                borderRadius: "4px",
                display: "none",
                width: c_width
            }).appendTo(document.body);
            var box0 = $("<div>").css({
                fontSize: '13px',
                color: '#aaa',
                float: 'left',
                paddingTop: '1px'
            }).appendTo(container);

            var width = $(this.options.width).val();
            var height = has_height ? $(this.options.height).val() : undefined;
            var max_w = '';
            var groupNode = this.options.groupNode;

            if (groupNode) {
                max_w = 'max="' + groupNode.width + '"';
            }
            width = (width > 0) ? width : 1;
            height = (height > 0) ? height : 1;
            var in0 = $('<input type="number" min="1" ' + max_w + '>')
                .css("width", has_height ? "45%" : "100%")
                .val(width)
                .appendTo(box0);
            if (has_height) {
                var pad = $('<span>')
                    .text(" x ")
                    .appendTo(box0);
                var in1 = $('<input type="number" min="1">')
                    .css("width", "45%")
                    .val(height)
                    .appendTo(box0);
            }
            var closeTimer;
            var closeFunc = function () {
                var w = in0.val();
                var h = has_height ? in1.val() : undefined;
                var label = that.options.label;
                label.text(w + (has_height ? (' x ' + h) : ''));
                $(that.options.width).val(w).change();
                if (has_height) {
                    $(that.options.height).val(h).change();
                }
                that.destroy();
            };
            container.keypress(function (e) {
                if (e.which === 13) { // pressed ENTER
                    container.fadeOut(100, closeFunc);
                }
            });
            container.on('mouseleave', function (e) {
                closeTimer = setTimeout(function () {
                    container.fadeOut(200, closeFunc);
                }, 100);
            });
            container.on('mouseenter', function (e) {
                clearTimeout(closeTimer);
            });
            container.css({
                top: (pos.top - 10) + "px",
                left: (pos.left + 10) + "px"
            });
            container.fadeIn(200);
        }
    });

    $.widget("nodereddashboard.elementSizer", {
        _create: function () {
            var that = this;
            var gridWidth = 6;
            var width = parseInt($(this.options.width).val() || 0);
            var height = parseInt(this.options.hasOwnProperty('height') ? $(this.options.height).val() : "1") || 0;
            var hasAuto = (!this.options.hasOwnProperty('auto') || this.options.auto);

            this.element.css({
                minWidth: this.element.height() + 4
            });
            var auto_text = "auto";
            var sizeLabel = (width === 0 && height === 0) ? auto_text : width + (this.options.hasOwnProperty('height') ? " x " + height : "");
            this.element.text(sizeLabel).on('mousedown', function (evt) {
                evt.stopPropagation();
                evt.preventDefault();

                var width = parseInt($(that.options.width).val() || 0);
                var height = parseInt(that.options.hasOwnProperty('height') ? $(that.options.height).val() : "1") || 0;
                var maxWidth = 0;
                var maxHeight;
                var fixedWidth = false;
                var fixedHeight = false;
                var group = $(that.options.group).val();
                if (group) {
                    var groupNode = RED.nodes.node(group);
                    if (groupNode) {
                        gridWidth = Math.max(6, groupNode.width, +width);
                        maxWidth = groupNode.width || gridWidth;
                        fixedWidth = true;
                    }
                    maxHeight = Math.max(6, +height + 1);
                }
                else {
                    gridWidth = Math.max(12, +width);
                    maxWidth = that.options.maxWidth;
                    maxHeight = that.options.maxHeight;
                    fixedHeight = that.options.fixedHeight;
                    fixedWidth = that.options.fixedWidth;
                }

                var pos = $(this).offset();
                var container = $('<div>').css({
                    position: 'absolute',
                    background: 'white',
                    padding: '5px 10px 10px 10px',
                    border: '1px solid grey',
                    zIndex: '20',
                    borderRadius: "4px",
                    display: "none"
                }).appendTo(document.body);
                var closeTimer;

                container.on('mouseleave', function (evt) {
                    closeTimer = setTimeout(function () {
                        container.fadeOut(200, function () { $(this).remove(); });
                    }, 100)
                });
                container.on('mouseenter', function () {
                    clearTimeout(closeTimer);
                })

                var label = $("<div>").css({
                    fontSize: '13px',
                    color: '#aaa',
                    float: 'left',
                    paddingTop: '1px'
                }).appendTo(container).text((width === 0 && height === 0) ? auto_text : (width + (that.options.hasOwnProperty('height') ? " x " + height : "")));
                label.hover(function () {
                    $(this).css('text-decoration', 'underline');
                }, function () {
                    $(this).css('text-decoration', 'none');
                });
                label.click(function (e) {
                    var group = $(that.options.group).val();
                    var groupNode = null;
                    if (group) {
                        groupNode = RED.nodes.node(group);
                        if (groupNode === null) {
                            return;
                        }
                    }
                    $(that).elementSizerByNum({
                        width: that.options.width,
                        height: that.options.height,
                        groupNode: groupNode,
                        pos: pos,
                        label: that.element,
                        has_height: that.options.hasOwnProperty('height')
                    });
                    closeTimer = setTimeout(function () {
                        container.fadeOut(200, function () {
                            $(this).remove();
                        });
                    }, 100)
                });

                var buttonRow = $('<div>', { style: "text-align:right; height:25px;" }).appendTo(container);

                if (hasAuto) {
                    var button = $('<a>', { href: "#", class: "editor-button editor-button-small", style: "margin-bottom:5px" })
                        .text(auto_text)
                        .appendTo(buttonRow)
                        .on('mouseup', function (evt) {
                            that.element.text(auto_text)
                            $(that.options.width).val(0).change();
                            $(that.options.height).val(0).change();
                            evt.preventDefault();
                            container.fadeOut(200, function () { $(this).remove(); });
                        });
                }

                var cellBorder = "1px dashed lightGray";
                var cellBorderExisting = "1px solid gray";
                var cellBorderHighlight = "1px dashed black";
                var rows = [];
                function addRow(i) {
                    var row = $('<div>').css({ padding: 0, margin: 0, height: "25px", "box-sizing": "border-box" }).appendTo(container);
                    rows.push(row);
                    cells.push([])
                    for (var j = 0; j < gridWidth; j++) {
                        addCell(i, j);
                    }
                }
                function addCell(i, j) {
                    var row = rows[i];
                    var cell = $('<div>').css({
                        display: "inline-block",
                        width: "25px",
                        height: "25px",
                        borderRight: (j === (width - 1) && i < height) ? cellBorderExisting : cellBorder,
                        borderBottom: (i === (height - 1) && j < width) ? cellBorderExisting : cellBorder,
                        boxSizing: "border-box",
                        cursor: "pointer",
                        background: (j < maxWidth) ? "#fff" : "#eee"
                    }).appendTo(row);
                    cells[i].push(cell);
                    if (j === 0) {
                        cell.css({ borderLeft: ((i <= height - 1) ? cellBorderExisting : cellBorder) });
                    }
                    if (i === 0) {
                        cell.css({ borderTop: ((j <= width - 1) ? cellBorderExisting : cellBorder) });
                    }
                    if (j < maxWidth) {
                        cell.data("w", j);
                        cell.data("h", i);
                        cell.on("mouseup", function () {
                            that.element.text(($(this).data("w") + 1) + (that.options.hasOwnProperty('height') ? " x " + ($(this).data("h") + 1) : ""))
                            $(that.options.width).val($(this).data("w") + 1).change();
                            $(that.options.height).val($(this).data("h") + 1).change();
                            container.fadeOut(200, function () { $(this).remove(); });
                        });
                        cell.on("mouseover", function () {
                            var w = $(this).data("w");
                            var h = $(this).data("h");
                            label.text((w + 1) + (that.options.hasOwnProperty('height') ? " x " + (h + 1) : ""));
                            for (var y = 0; y < maxHeight; y++) {
                                for (var x = 0; x < maxWidth; x++) {
                                    cells[y][x].css({
                                        background: (y <= h && x <= w) ? '#ddd' : '#fff',
                                        borderLeft: (x === 0 && y <= h) ? cellBorderHighlight : (x === 0) ? ((y <= height - 1) ? cellBorderExisting : cellBorder) : '',
                                        borderTop: (y === 0 && x <= w) ? cellBorderHighlight : (y === 0) ? ((x <= width - 1) ? cellBorderExisting : cellBorder) : '',
                                        borderRight: (x === w && y <= h) ? cellBorderHighlight : ((x === width - 1 && y <= height - 1) ? cellBorderExisting : cellBorder),
                                        borderBottom: (y === h && x <= w) ? cellBorderHighlight : ((y === height - 1 && x <= width - 1) ? cellBorderExisting : cellBorder)
                                    })
                                }
                            }
                            if (!fixedHeight && h === maxHeight - 1) {
                                addRow(maxHeight++)
                            }
                            if (!fixedWidth && w === maxWidth - 1) {
                                maxWidth++;
                                gridWidth++;
                                for (var r = 0; r < maxHeight; r++) {
                                    addCell(r, maxWidth - 1);
                                }
                            }
                        })
                    }
                }
                var cells = [];
                for (var i = 0; i < maxHeight; i++) {
                    addRow(i);
                }
                container.css({
                    top: (pos.top) + "px",
                    left: (pos.left) + "px"
                });
                container.fadeIn(200);
            })
        }
    });


}(jQuery);